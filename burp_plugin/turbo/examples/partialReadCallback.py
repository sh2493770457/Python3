"""
部分读取回调脚本 - Turbo Intruder

功能说明：
这是一个演示部分读取回调功能的高级脚本。
脚本可以在响应数据流式传输过程中实时处理数据，无需等待完整响应。

主要特性：
1. 流式数据处理 - 实时处理响应数据流
2. 自定义读取回调 - 在数据到达时立即处理
3. 动态请求生成 - 基于部分响应内容生成新请求
4. 低延迟处理 - 无需等待完整响应

使用场景：
- 实时令牌提取和利用
- 流式数据分析
- 大文件响应的增量处理
- 实时攻击链构建
- 低延迟的响应处理

技术特点：
- TCP套接字级别的数据读取
- 可配置的读取缓冲区大小
- 实时数据流处理
- 动态攻击流程控制

参数配置：
- concurrentConnections: 2（并发连接数）
- readCallback: handleRead（读取回调函数）
- readSize: 256（TCP套接字缓冲区大小，服务器可能发送更少数据）

工作原理：
1. 设置读取回调函数
2. 发送初始请求
3. 在数据到达时触发回调
4. 实时分析数据内容
5. 基于内容动态生成新请求

回调机制：
- data参数只包含最后一次套接字读取的内容
- 如果运气不好，令牌可能会被分割到两次读取中
- 需要考虑数据分片的情况

注意事项：
- 数据可能被分割到多次读取中
- 回调函数中的延迟会影响后续读取
- 需要处理不完整的数据
- 适合对时序敏感的攻击

使用方法：
1. 定义读取回调函数
2. 配置读取缓冲区大小
3. 发送初始请求
4. 监控实时数据处理

高级应用：
- 实时令牌提取
- 流式日志分析
- 增量数据处理
- 实时攻击响应

性能考虑：
- 回调函数应尽量轻量
- 避免在回调中进行耗时操作
- 考虑数据缓冲和重组
- 注意内存使用情况
"""

def queueRequests(target, wordlists):
    global engine
    # 创建支持部分读取回调的请求引擎
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=2,         # 并发连接数
                           readCallback=handleRead,         # 读取回调函数
                           readSize=256,                    # TCP套接字缓冲区大小（服务器可能发送更少）
                           )

    # 发送初始请求
    engine.queue(target.req)

def handleRead(data):
    """
    读取回调函数 - 实时处理响应数据流

    参数：
    - data: 仅包含最后一次套接字读取的内容

    注意：
    - 如果运气不好，令牌可能会被分割到两次读取中
    - 需要考虑数据分片的处理
    """
    # 检测响应中是否包含令牌
    if 'token' in data:
        # 立即使用检测到的令牌生成新请求
        engine.queue('something-using-the-token')
        time.sleep(1)  # 这会延迟此响应的剩余读取操作

    # 可以添加更多实时处理逻辑：
    # - 提取特定模式的数据
    # - 触发条件性攻击
    # - 实时数据验证
    # - 动态攻击调整

def handleResponse(req, interesting):
    # 处理完整的响应
    table.add(req)

    # 可以在这里进行完整响应的后处理：
    # - 验证部分读取的结果
    # - 进行完整性检查
    # - 记录攻击效果
